syntax = "proto3";
package influxdata.iox.management.v1;
option go_package = "github.com/influxdata/iox/management/v1";

import "google/longrunning/operations.proto";
import "google/protobuf/field_mask.proto";
import "influxdata/iox/management/v1/database_rules.proto";
import "influxdata/iox/management/v1/chunk.proto";
import "influxdata/iox/management/v1/partition.proto";

service ManagementService {
  rpc GetServerId(GetServerIdRequest) returns (GetServerIdResponse);

  rpc UpdateServerId(UpdateServerIdRequest) returns (UpdateServerIdResponse);

  rpc SetServingReadiness(SetServingReadinessRequest) returns (SetServingReadinessResponse);

  // List all databases on this server.
  //
  // Roughly follows the <https://google.aip.dev/132> pattern, except we wrap the response
  rpc ListDatabases(ListDatabasesRequest) returns (ListDatabasesResponse);

  // Return a specific database by name
  //
  // Roughly follows the <https://google.aip.dev/131> pattern, except
  // we wrap the response
  rpc GetDatabase(GetDatabaseRequest) returns (GetDatabaseResponse);

  rpc CreateDatabase(CreateDatabaseRequest) returns (CreateDatabaseResponse);

  // Update a database.
  //
  // Roughly follows the <https://google.aip.dev/134> pattern, except we wrap the response
  rpc UpdateDatabase(UpdateDatabaseRequest) returns (UpdateDatabaseResponse);

  rpc DeleteDatabase(DeleteDatabaseRequest) returns (DeleteDatabaseResponse);

  // List chunks available on this database
  rpc ListChunks(ListChunksRequest) returns (ListChunksResponse);

  // List remote IOx servers we know about.
  rpc ListRemotes(ListRemotesRequest) returns (ListRemotesResponse);

  // Update information about a remote IOx server (upsert).
  rpc UpdateRemote(UpdateRemoteRequest) returns (UpdateRemoteResponse);

  // Delete a reference to remote IOx server.
  rpc DeleteRemote(DeleteRemoteRequest) returns (DeleteRemoteResponse);

  // Creates a dummy job that for each value of the nanos field
  // spawns a task that sleeps for that number of nanoseconds before returning
  rpc CreateDummyJob(CreateDummyJobRequest) returns (CreateDummyJobResponse) {
    option (google.longrunning.operation_info) = {
      response_type: "google.protobuf.Empty"
      metadata_type: "OperationMetadata"
    };
  }

  // List partitions in a database
  rpc ListPartitions(ListPartitionsRequest) returns (ListPartitionsResponse);

  // Get detail information about a partition
  rpc GetPartition(GetPartitionRequest) returns (GetPartitionResponse);

  // List chunks in a partition
  rpc ListPartitionChunks(ListPartitionChunksRequest) returns (ListPartitionChunksResponse);

  // Create a new chunk in the mutable buffer
  rpc NewPartitionChunk(NewPartitionChunkRequest) returns (NewPartitionChunkResponse);

  // Close a chunk and move it to the read buffer
  rpc ClosePartitionChunk(ClosePartitionChunkRequest) returns (ClosePartitionChunkResponse);

  // Unload chunk from read buffer but keep it in object store
  rpc UnloadPartitionChunk(UnloadPartitionChunkRequest) returns (UnloadPartitionChunkResponse);

  // Get server status
  rpc GetServerStatus(GetServerStatusRequest) returns (GetServerStatusResponse);

  // Wipe preserved catalog for given DB.
  rpc WipePreservedCatalog(WipePreservedCatalogRequest) returns (WipePreservedCatalogResponse);

  // Skip replay for given DB.
  rpc SkipReplay(SkipReplayRequest) returns (SkipReplayResponse);

  // Persist given partition.
  //
  // Errors if there is nothing to persist at the moment as per the lifecycle rules. If successful it returns the
  // chunk that contains the persisted data.
  rpc PersistPartition(PersistPartitionRequest) returns (PersistPartitionResponse);

  // Drop partition from memory and (if persisted) from object store.
  rpc DropPartition(DropPartitionRequest) returns (DropPartitionResponse);

  // Delete data for a table on a specified predicate
  rpc Delete(DeleteRequest) returns (DeleteResponse);
}

message GetServerIdRequest {}

message GetServerIdResponse {
  uint32 id = 1;
}

message UpdateServerIdRequest {
  uint32 id = 1;
}

message UpdateServerIdResponse {}

message SetServingReadinessRequest {
  // If false, the IOx server will respond with UNAVAILABLE to all data plane requests.
  bool ready = 1;
}

message SetServingReadinessResponse {}

message ListDatabasesRequest {
  // If true, returns only explciitly defined values. See additional
  // details on `GetDatabaseRequest`.
  bool omit_defaults = 1;
}

message ListDatabasesResponse {
  // old version of this API returned names only.
  // repeated string names = 1;

  /// database rules (configuration) for each database
  repeated DatabaseRules rules = 2;
}

message GetDatabaseRequest {
  // The name of the database to retrieve
  string name = 1;

  // If false, or unspecified: return the current configuration that is being used by
  // the server, with all default values filled in.
  //
  // If true, returns only the persisted configuration (aka only
  // fields which were was supplied when the database was created or
  // last modified via UpdateDatabase)
  bool omit_defaults = 2;
}

message GetDatabaseResponse {
  DatabaseRules rules = 1;
}

message CreateDatabaseRequest {
  DatabaseRules rules = 1;
}

message CreateDatabaseResponse {}

// Update a database.
message UpdateDatabaseRequest {
  // The rule's `name` field is used to identify the database rules to be updated.
  DatabaseRules rules = 1;
}

message UpdateDatabaseResponse {
  DatabaseRules rules = 1;
}

message DeleteDatabaseRequest {
  // the name of the database
  string db_name = 1;
}

message DeleteDatabaseResponse {}

message ListChunksRequest {
  // the name of the database
  string db_name = 1;
}

message ListChunksResponse {
  repeated Chunk chunks = 1;
}

message CreateDummyJobRequest {
  repeated uint64 nanos = 1;
}

message CreateDummyJobResponse {
  google.longrunning.Operation operation = 1;
}

message ListRemotesRequest {}

message ListRemotesResponse {
  repeated Remote remotes = 1;
}

// This resource represents a remote IOx server.
message Remote {
  // The server ID associated with a remote IOx server.
  uint32 id = 1;

  // The address of the remote IOx server gRPC endpoint.
  string connection_string = 2;
}

// Updates information about a remote IOx server.
//
// If a remote for a given `id` already exists, it is updated in place.
message UpdateRemoteRequest {
  // If omitted, the remote associated with `id` will be removed.
  Remote remote = 1;

  // TODO(#917): add an optional flag to test the connection or not before adding it.
}

message UpdateRemoteResponse {}

message DeleteRemoteRequest{
  uint32 id = 1;
}

message DeleteRemoteResponse {}

// Request to list all partitions from a named database
message ListPartitionsRequest {
  // the name of the database
  string db_name = 1;
}

message ListPartitionsResponse {
  // All partitions in a database
  repeated Partition partitions = 1;
}

// Request to list all chunks in a specific partitions from a named database
message ListPartitionChunksRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;
}

message GetPartitionResponse {
  // Detailed information about a partition
  Partition partition = 1;
}

message ListPartitionChunksResponse {
  // All chunks in a partition
  repeated Chunk chunks = 1;
}

// Request to get details of a specific partition from a named database
message GetPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;
}

// Request that a new chunk for writing is created in the mutable buffer
message NewPartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message NewPartitionChunkResponse {
}

// Request that a chunk be closed and moved to the read buffer
message ClosePartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 4;

  // the chunk id
  uint32 chunk_id = 3;
}

message ClosePartitionChunkResponse {
  // The operation that tracks the work for migrating the chunk
  google.longrunning.Operation operation = 1;
}

// Request to unload chunk from read buffer but keep it in object store
message UnloadPartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 4;

  // the chunk id
  uint32 chunk_id = 3;
}

message UnloadPartitionChunkResponse {
}

message GetServerStatusRequest {}
message GetServerStatusResponse {
  // Server status.
  ServerStatus server_status = 1;
}

message ServerStatus {
  // Server is initialized, i.e. databases are loaded and accept read/write operations. Furthermore database rules can
  // be updaded and new databases can be created.
  bool initialized = 1;

  // If present, the server reports a global error condition.
  Error error = 2;

  // If `initialized` is true, this contains a complete list of databases.
  repeated DatabaseStatus database_statuses = 3;
}

message DatabaseStatus {
  // The name of the database.
  string db_name = 1;

  // If present, the database reports an error condition.
  Error error = 2;

  // Current initialization state of the database.
  enum DatabaseState {
    DATABASE_STATE_UNSPECIFIED = 0;

    // Database is known but nothing is loaded.
    DATABASE_STATE_KNOWN = 1;

		// Database object storage has been found
		DATABASE_STATE_DATABASE_OBJECT_STORE_FOUND = 8;

    // Rules are loaded
    DATABASE_STATE_RULES_LOADED = 2;

    // Catalog is loaded but data from sequencers / write buffers is not yet replayed.
    DATABASE_STATE_CATALOG_LOADED = 3;

    // Fully initialized database.
    DATABASE_STATE_INITIALIZED = 4;

    // Error loading rules
    DATABASE_STATE_RULES_LOAD_ERROR = 5;

    // Error during catalog load
    DATABASE_STATE_CATALOG_LOAD_ERROR = 6;

    // Error during replay
    DATABASE_STATE_REPLAY_ERROR = 7;
  }

  // Current initialization state of the database.
  DatabaseState state = 3;
}

message Error {
  // Message descripting the error.
  string message = 1;
}

// Request to wipe preserved catalog.
message WipePreservedCatalogRequest {
  // the name of the database
  string db_name = 1;
}

message WipePreservedCatalogResponse {
  // The operation that tracks the work for wiping the catalog.
  google.longrunning.Operation operation = 1;
}

// Request to skip replay.
message SkipReplayRequest {
  // the name of the database
  string db_name = 1;
}

message SkipReplayResponse {
}

// Request to persist given partition.
message PersistPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message PersistPartitionResponse {
}

// Request to drop partition from memory and (if persisted) from object store.
message DropPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message DropPartitionResponse {
}

// Request to delete data from a table on a specified predicate
message DeleteRequest {
  // name of the database
  string db_name = 1;

  // table name
  string table_name = 2;

  // delete predicate
  // Ideally, this can be any complicated expressions that DataFusion supports
  // but in our first version, we only support what our read buffer does which is 
  // conjunctive expressions with columns being compared to literals using = or != operators.
  // Also, to avoid user making mistake deleting the whole table, we will force them to
  // inlcude delete time range start and stop in different fields defined below
  string delete_predicate = 3;

  // start time range of deleting data
  string start_time = 4;

  // stop time range of deleting data
  string stop_time = 5;
}

message DeleteResponse {
  // todo
  // string delete_status = 1;
}
