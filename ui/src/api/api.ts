// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Influx API Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost:9999/api/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * contains the AST for the supplied Flux query
 * @export
 * @interface ASTResponse
 */
export interface ASTResponse {
    /**
     * the AST of the supplied Flux query
     * @type {any}
     * @memberof ASTResponse
     */
    ast?: any;
}

/**
 * 
 * @export
 * @interface AnalyzeQueryResponse
 */
export interface AnalyzeQueryResponse {
    /**
     * 
     * @type {Array<AnalyzeQueryResponseErrors>}
     * @memberof AnalyzeQueryResponse
     */
    errors?: Array<AnalyzeQueryResponseErrors>;
}

/**
 * 
 * @export
 * @interface AnalyzeQueryResponseErrors
 */
export interface AnalyzeQueryResponseErrors {
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    line?: number;
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    column?: number;
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    character?: number;
    /**
     * 
     * @type {string}
     * @memberof AnalyzeQueryResponseErrors
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * ID of org that authorization is scoped to.
     * @type {string}
     * @memberof Authorization
     */
    orgID: string;
    /**
     * if inactive the token is inactive and requests using the token will be rejected.
     * @type {string}
     * @memberof Authorization
     */
    status?: Authorization.StatusEnum;
    /**
     * A description of the token.
     * @type {string}
     * @memberof Authorization
     */
    description?: string;
    /**
     * List of permissions for an auth.  An auth must have at least one Permission.
     * @type {Array<Permission>}
     * @memberof Authorization
     */
    permissions: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    id?: string;
    /**
     * Passed via the Authorization Header and Token Authentication type.
     * @type {string}
     * @memberof Authorization
     */
    token?: string;
    /**
     * ID of user that created and owns the token.
     * @type {string}
     * @memberof Authorization
     */
    userID?: string;
    /**
     * Name of user that created and owns the token.
     * @type {string}
     * @memberof Authorization
     */
    user?: string;
    /**
     * Name of the org token is scoped to.
     * @type {string}
     * @memberof Authorization
     */
    org?: string;
    /**
     * 
     * @type {AuthorizationLinks}
     * @memberof Authorization
     */
    links?: AuthorizationLinks;
}

/**
 * @export
 * @namespace Authorization
 */
export namespace Authorization {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface AuthorizationLinks
 */
export interface AuthorizationLinks {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationLinks
     */
    user?: string;
}

/**
 * 
 * @export
 * @interface Authorizations
 */
export interface Authorizations {
    /**
     * 
     * @type {Links}
     * @memberof Authorizations
     */
    links?: Links;
    /**
     * 
     * @type {Array<Authorization>}
     * @memberof Authorizations
     */
    authorizations?: Array<Authorization>;
}

/**
 * A description of a particular axis for a visualization
 * @export
 * @interface Axis
 */
export interface Axis {
    /**
     * The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits
     * @type {Array<number>}
     * @memberof Axis
     */
    bounds?: Array<number>;
    /**
     * label is a description of this Axis
     * @type {string}
     * @memberof Axis
     */
    label?: string;
    /**
     * Prefix represents a label prefix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    prefix?: string;
    /**
     * Suffix represents a label suffix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    suffix?: string;
    /**
     * Base represents the radix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    base?: string;
    /**
     * Scale is the axis formatting scale. Supported: \"log\", \"linear\"
     * @type {string}
     * @memberof Axis
     */
    scale?: string;
}

/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {BucketLinks}
     * @memberof Bucket
     */
    links?: BucketLinks;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    id?: string;
    /**
     * 
     * @type {Owners}
     * @memberof Bucket
     */
    owners?: Owners;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    rp?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    organizationID?: string;
    /**
     * rules to expire or retain data.  No rules means data never expires.
     * @type {Array<BucketRetentionRules>}
     * @memberof Bucket
     */
    retentionRules: Array<BucketRetentionRules>;
}

/**
 * 
 * @export
 * @interface BucketLinks
 */
export interface BucketLinks {
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    org?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    write?: string;
}

/**
 * 
 * @export
 * @interface BucketRetentionRules
 */
export interface BucketRetentionRules {
    /**
     * 
     * @type {string}
     * @memberof BucketRetentionRules
     */
    type: BucketRetentionRules.TypeEnum;
    /**
     * duration in seconds for how long data will be kept in the database.
     * @type {number}
     * @memberof BucketRetentionRules
     */
    everySeconds: number;
}

/**
 * @export
 * @namespace BucketRetentionRules
 */
export namespace BucketRetentionRules {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Expire = 'expire'
    }
}

/**
 * 
 * @export
 * @interface Buckets
 */
export interface Buckets {
    /**
     * 
     * @type {Links}
     * @memberof Buckets
     */
    links?: Links;
    /**
     * 
     * @type {Array<Bucket>}
     * @memberof Buckets
     */
    buckets?: Array<Bucket>;
}

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    id?: string;
    /**
     * 
     * @type {CellLinks}
     * @memberof Cell
     */
    links?: CellLinks;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    h?: number;
}

/**
 * 
 * @export
 * @interface CellLinks
 */
export interface CellLinks {
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    view?: string;
}

/**
 * 
 * @export
 * @interface CellUpdate
 */
export interface CellUpdate {
    /**
     * 
     * @type {string}
     * @memberof CellUpdate
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ConstantMacroProperties
 */
export interface ConstantMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof ConstantMacroProperties
     */
    type?: ConstantMacroProperties.TypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConstantMacroProperties
     */
    values?: Array<string>;
}

/**
 * @export
 * @namespace ConstantMacroProperties
 */
export namespace ConstantMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Constant = 'constant'
    }
}

/**
 * 
 * @export
 * @interface CreateCell
 */
export interface CreateCell {
    /**
     * 
     * @type {string}
     * @memberof CreateCell
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    h?: number;
    /**
     * makes a copy of the provided view
     * @type {string}
     * @memberof CreateCell
     */
    usingView?: string;
}

/**
 * 
 * @export
 * @interface CreateProtoResourcesRequest
 */
export interface CreateProtoResourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateProtoResourcesRequest
     */
    orgID?: string;
}

/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * 
     * @type {DashboardLinks}
     * @memberof Dashboard
     */
    links?: DashboardLinks;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    id?: string;
    /**
     * id of organization that owns dashboard
     * @type {string}
     * @memberof Dashboard
     */
    orgID?: string;
    /**
     * user-facing name of the dashboard
     * @type {string}
     * @memberof Dashboard
     */
    name?: string;
    /**
     * user-facing description of the dashboard
     * @type {string}
     * @memberof Dashboard
     */
    description?: string;
    /**
     * 
     * @type {DashboardMeta}
     * @memberof Dashboard
     */
    meta?: DashboardMeta;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Dashboard
     */
    cells?: Array<Cell>;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Dashboard
     */
    labels?: Array<Label>;
}

/**
 * Color defines an encoding of data value into color space
 * @export
 * @interface DashboardColor
 */
export interface DashboardColor {
    /**
     * ID is the unique id of the view color
     * @type {string}
     * @memberof DashboardColor
     */
    id?: string;
    /**
     * Type is how the color is used.
     * @type {string}
     * @memberof DashboardColor
     */
    type?: DashboardColor.TypeEnum;
    /**
     * Hex is the hex number of the color
     * @type {string}
     * @memberof DashboardColor
     */
    hex?: string;
    /**
     * Name is the user-facing name of the hex color
     * @type {string}
     * @memberof DashboardColor
     */
    name?: string;
    /**
     * Value is the data value mapped to this color
     * @type {number}
     * @memberof DashboardColor
     */
    value?: number;
}

/**
 * @export
 * @namespace DashboardColor
 */
export namespace DashboardColor {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Min = 'min',
        Max = 'max',
        Threshold = 'threshold'
    }
}

/**
 * 
 * @export
 * @interface DashboardLinks
 */
export interface DashboardLinks {
    /**
     * 
     * @type {string}
     * @memberof DashboardLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardLinks
     */
    cells?: string;
}

/**
 * 
 * @export
 * @interface DashboardMeta
 */
export interface DashboardMeta {
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface DashboardQuery
 */
export interface DashboardQuery {
    /**
     * Optional Y-axis user-facing label
     * @type {string}
     * @memberof DashboardQuery
     */
    label?: string;
    /**
     * 
     * @type {DashboardQueryRange}
     * @memberof DashboardQuery
     */
    range?: DashboardQueryRange;
    /**
     * 
     * @type {string}
     * @memberof DashboardQuery
     */
    query: string;
    /**
     * Optional URI for data source for this query
     * @type {string}
     * @memberof DashboardQuery
     */
    source?: string;
    /**
     * 
     * @type {QueryConfig}
     * @memberof DashboardQuery
     */
    queryConfig?: QueryConfig;
    /**
     * An optional word or phrase that refers to the query
     * @type {string}
     * @memberof DashboardQuery
     */
    name?: string;
}

/**
 * Optional default range of the Y-axis
 * @export
 * @interface DashboardQueryRange
 */
export interface DashboardQueryRange {
    /**
     * Upper bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    upper: number;
    /**
     * Lower bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    lower: number;
}

/**
 * 
 * @export
 * @interface Dashboards
 */
export interface Dashboards {
    /**
     * 
     * @type {Links}
     * @memberof Dashboards
     */
    links?: Links;
    /**
     * 
     * @type {Array<Dashboard>}
     * @memberof Dashboards
     */
    dashboards?: Array<Dashboard>;
}

/**
 * dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 * @export
 * @interface Dialect
 */
export interface Dialect {
    /**
     * if true, the results will contain a header row
     * @type {boolean}
     * @memberof Dialect
     */
    header?: boolean;
    /**
     * separator between cells; the default is ,
     * @type {string}
     * @memberof Dialect
     */
    delimiter?: string;
    /**
     * https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns
     * @type {Array<string>}
     * @memberof Dialect
     */
    annotations?: Array<Dialect.AnnotationsEnum>;
    /**
     * character prefixed to comment strings
     * @type {string}
     * @memberof Dialect
     */
    commentPrefix?: string;
    /**
     * format of timestamps
     * @type {string}
     * @memberof Dialect
     */
    dateTimeFormat?: Dialect.DateTimeFormatEnum;
}

/**
 * @export
 * @namespace Dialect
 */
export namespace Dialect {
    /**
     * @export
     * @enum {string}
     */
    export enum AnnotationsEnum {
        Group = 'group',
        Datatype = 'datatype',
        Default = 'default'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DateTimeFormatEnum {
        RFC3339 = 'RFC3339',
        RFC3339Nano = 'RFC3339Nano'
    }
}

/**
 * 
 * @export
 * @interface EmptyViewProperties
 */
export interface EmptyViewProperties {
    /**
     * 
     * @type {string}
     * @memberof EmptyViewProperties
     */
    type?: EmptyViewProperties.TypeEnum;
}

/**
 * @export
 * @namespace EmptyViewProperties
 */
export namespace EmptyViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Empty = 'empty'
    }
}

/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * value is the value of the field.  Meaning of the value is implied by the `type` key
     * @type {string}
     * @memberof Field
     */
    value?: string;
    /**
     * type describes the field type. func is a function; field is a field reference
     * @type {string}
     * @memberof Field
     */
    type?: Field.TypeEnum;
    /**
     * Alias overrides the field name in the returned response.  Applies only if type is `func`
     * @type {string}
     * @memberof Field
     */
    alias?: string;
    /**
     * Args are the arguments to the function
     * @type {Array<Field>}
     * @memberof Field
     */
    args?: Array<Field>;
}

/**
 * @export
 * @namespace Field
 */
export namespace Field {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Func = 'func',
        Field = 'field',
        Integer = 'integer',
        Number = 'number',
        Regex = 'regex',
        Wildcard = 'wildcard'
    }
}

/**
 * 
 * @export
 * @interface FluxLinks
 */
export interface FluxLinks {
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    ast?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    suggestions?: string;
}

/**
 * 
 * @export
 * @interface FluxSuggestions
 */
export interface FluxSuggestions {
    /**
     * 
     * @type {FluxSuggestionsFuncs}
     * @memberof FluxSuggestions
     */
    funcs?: FluxSuggestionsFuncs;
}

/**
 * 
 * @export
 * @interface FluxSuggestionsFuncs
 */
export interface FluxSuggestionsFuncs {
    /**
     * 
     * @type {string}
     * @memberof FluxSuggestionsFuncs
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof FluxSuggestionsFuncs
     */
    params?: any;
}

/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    message?: string;
    /**
     * 
     * @type {Array<Health>}
     * @memberof Health
     */
    checks?: Array<Health>;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    status?: Health.StatusEnum;
}

/**
 * @export
 * @namespace Health
 */
export namespace Health {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Unhealthy = 'unhealthy',
        Healthy = 'healthy'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Task>}
     * @memberof InlineResponse200
     */
    tasks?: Array<Task>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse200
     */
    links?: Links;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<Run>}
     * @memberof InlineResponse2001
     */
    runs?: Array<Run>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2001
     */
    links?: Links;
}

/**
 * 
 * @export
 * @interface IsOnboarding
 */
export interface IsOnboarding {
    /**
     * 
     * @type {boolean}
     * @memberof IsOnboarding
     */
    allowed?: boolean;
}

/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    name?: string;
    /**
     * Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.
     * @type {any}
     * @memberof Label
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface LabelMapping
 */
export interface LabelMapping {
    /**
     * 
     * @type {string}
     * @memberof LabelMapping
     */
    labelID?: string;
}

/**
 * 
 * @export
 * @interface LabelResponse
 */
export interface LabelResponse {
    /**
     * 
     * @type {Label}
     * @memberof LabelResponse
     */
    label?: Label;
    /**
     * 
     * @type {Links}
     * @memberof LabelResponse
     */
    links?: Links;
}

/**
 * 
 * @export
 * @interface LabelUpdate
 */
export interface LabelUpdate {
    /**
     * Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.
     * @type {any}
     * @memberof LabelUpdate
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface LabelsResponse
 */
export interface LabelsResponse {
    /**
     * 
     * @type {Array<Label>}
     * @memberof LabelsResponse
     */
    labels?: Array<Label>;
    /**
     * 
     * @type {Links}
     * @memberof LabelsResponse
     */
    links?: Links;
}

/**
 * flux query to be analyzed.
 * @export
 * @interface LanguageRequest
 */
export interface LanguageRequest {
    /**
     * flux query script to be analyzed
     * @type {string}
     * @memberof LanguageRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface LineProtocolError
 */
export interface LineProtocolError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolError
     */
    code: LineProtocolError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    op: string;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    err: string;
    /**
     * first line within sent body containing malformed data
     * @type {number}
     * @memberof LineProtocolError
     */
    line?: number;
}

/**
 * @export
 * @namespace LineProtocolError
 */
export namespace LineProtocolError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        EmptyValue = 'empty value'
    }
}

/**
 * 
 * @export
 * @interface LineProtocolLengthError
 */
export interface LineProtocolLengthError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    code: LineProtocolLengthError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    message: string;
    /**
     * max length in bytes for a body of line-protocol.
     * @type {number}
     * @memberof LineProtocolLengthError
     */
    maxLength: number;
}

/**
 * @export
 * @namespace LineProtocolLengthError
 */
export namespace LineProtocolLengthError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        Invalid = 'invalid'
    }
}

/**
 * URI of resource.
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href: string;
}

/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    next?: Link;
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    prev?: Link;
}

/**
 * 
 * @export
 * @interface LogEvent
 */
export interface LogEvent {
    /**
     * Time event occurred, RFC3339Nano.
     * @type {Date}
     * @memberof LogEvent
     */
    time?: Date;
    /**
     * A description of the event that occurred.
     * @type {string}
     * @memberof LogEvent
     */
    message?: string;
}

/**
 * Contains the configuration for the log viewer
 * @export
 * @interface LogViewProperties
 */
export interface LogViewProperties {
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    shape: LogViewProperties.ShapeEnum;
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    type: LogViewProperties.TypeEnum;
    /**
     * Defines the order, names, and visibility of columns in the log viewer table
     * @type {Array<LogViewerColumn>}
     * @memberof LogViewProperties
     */
    columns: Array<LogViewerColumn>;
}

/**
 * @export
 * @namespace LogViewProperties
 */
export namespace LogViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum ShapeEnum {
        ChronografV2 = 'chronograf-v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LogViewer = 'log-viewer'
    }
}

/**
 * Contains a specific column's settings.
 * @export
 * @interface LogViewerColumn
 */
export interface LogViewerColumn {
    /**
     * Unique identifier name of the column
     * @type {string}
     * @memberof LogViewerColumn
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof LogViewerColumn
     */
    position: number;
    /**
     * Composable settings options for the column
     * @type {Array<LogViewerColumnSettings>}
     * @memberof LogViewerColumn
     */
    settings: Array<LogViewerColumnSettings>;
}

/**
 * Type and value and optional name of a setting.
 * @export
 * @interface LogViewerColumnSettings
 */
export interface LogViewerColumnSettings {
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Logs
 */
export interface Logs {
    /**
     * 
     * @type {Array<LogEvent>}
     * @memberof Logs
     */
    events?: Array<LogEvent>;
}

/**
 * 
 * @export
 * @interface Macro
 */
export interface Macro {
    /**
     * 
     * @type {ResourceOwnersLinks}
     * @memberof Macro
     */
    links?: ResourceOwnersLinks;
    /**
     * 
     * @type {string}
     * @memberof Macro
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Macro
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Macro
     */
    selected?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof Macro
     */
    arguments?: any;
}

/**
 * 
 * @export
 * @interface Macros
 */
export interface Macros {
    /**
     * 
     * @type {Macro}
     * @memberof Macros
     */
    macros?: Macro;
}

/**
 * 
 * @export
 * @interface MapMacroProperties
 */
export interface MapMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof MapMacroProperties
     */
    type?: MapMacroProperties.TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof MapMacroProperties
     */
    values?: any;
}

/**
 * @export
 * @namespace MapMacroProperties
 */
export namespace MapMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Map = 'map'
    }
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof ModelError
     */
    code: ModelError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    op: string;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    err: string;
}

/**
 * @export
 * @namespace ModelError
 */
export namespace ModelError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        EmptyValue = 'empty value'
    }
}

/**
 * 
 * @export
 * @interface OnboardingRequest
 */
export interface OnboardingRequest {
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    org: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    bucket: string;
    /**
     * 
     * @type {number}
     * @memberof OnboardingRequest
     */
    retentionPeriodHrs?: number;
}

/**
 * 
 * @export
 * @interface OnboardingResponse
 */
export interface OnboardingResponse {
    /**
     * 
     * @type {User}
     * @memberof OnboardingResponse
     */
    user?: User;
    /**
     * 
     * @type {Organization}
     * @memberof OnboardingResponse
     */
    org?: Organization;
    /**
     * 
     * @type {Bucket}
     * @memberof OnboardingResponse
     */
    bucket?: Bucket;
    /**
     * 
     * @type {Authorization}
     * @memberof OnboardingResponse
     */
    auth?: Authorization;
}

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {OrganizationLinks}
     * @memberof Organization
     */
    links?: OrganizationLinks;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * if inactive the organization is inactive.
     * @type {string}
     * @memberof Organization
     */
    status?: Organization.StatusEnum;
    /**
     * 
     * @type {Owners}
     * @memberof Organization
     */
    owners?: Owners;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface OrganizationLinks
 */
export interface OrganizationLinks {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    users?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    buckets?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    tasks?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    dashboards?: string;
}

/**
 * 
 * @export
 * @interface Organizations
 */
export interface Organizations {
    /**
     * 
     * @type {Links}
     * @memberof Organizations
     */
    links?: Links;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof Organizations
     */
    orgs?: Array<Organization>;
}

/**
 * 
 * @export
 * @interface Owners
 */
export interface Owners {
    /**
     * 
     * @type {Users}
     * @memberof Owners
     */
    users?: Users;
    /**
     * 
     * @type {Organizations}
     * @memberof Owners
     */
    organizations?: Organizations;
}

/**
 * 
 * @export
 * @interface PasswordResetBody
 */
export interface PasswordResetBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetBody
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    action: Permission.ActionEnum;
    /**
     * 
     * @type {PermissionResource}
     * @memberof Permission
     */
    resource: PermissionResource;
}

/**
 * @export
 * @namespace Permission
 */
export namespace Permission {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Read = 'read',
        Write = 'write'
    }
}

/**
 * 
 * @export
 * @interface PermissionResource
 */
export interface PermissionResource {
    /**
     * 
     * @type {string}
     * @memberof PermissionResource
     */
    type: PermissionResource.TypeEnum;
    /**
     * if id is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type.
     * @type {string}
     * @memberof PermissionResource
     */
    id?: string;
    /**
     * optional name of the resource if the resource has a name field.
     * @type {string}
     * @memberof PermissionResource
     */
    name?: string;
    /**
     * if orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type.
     * @type {string}
     * @memberof PermissionResource
     */
    orgID?: string;
    /**
     * optional name of the organization of the organization with orgID.
     * @type {string}
     * @memberof PermissionResource
     */
    org?: string;
}

/**
 * @export
 * @namespace PermissionResource
 */
export namespace PermissionResource {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Authorizations = 'authorizations',
        Buckets = 'buckets',
        Dashboards = 'dashboards',
        Orgs = 'orgs',
        Sources = 'sources',
        Tasks = 'tasks',
        Telegrafs = 'telegrafs',
        Users = 'users'
    }
}

/**
 * 
 * @export
 * @interface Proto
 */
export interface Proto {
    /**
     * 
     * @type {ProtoLinks}
     * @memberof Proto
     */
    links?: ProtoLinks;
    /**
     * 
     * @type {string}
     * @memberof Proto
     */
    id?: string;
    /**
     * user-facing name of the proto
     * @type {string}
     * @memberof Proto
     */
    name?: string;
    /**
     * 
     * @type {Array<Dashboard>}
     * @memberof Proto
     */
    dashboards?: Array<Dashboard>;
    /**
     * 
     * @type {{ [key: string]: View; }}
     * @memberof Proto
     */
    views?: { [key: string]: View; };
}

/**
 * 
 * @export
 * @interface ProtoLinks
 */
export interface ProtoLinks {
    /**
     * 
     * @type {string}
     * @memberof ProtoLinks
     */
    dashboard?: string;
}

/**
 * 
 * @export
 * @interface Protos
 */
export interface Protos {
    /**
     * 
     * @type {Array<Proto>}
     * @memberof Protos
     */
    protos?: Array<Proto>;
}

/**
 * query influx with specified return formatting. The spec and query fields are mutually exclusive.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * query script to execute.
     * @type {string}
     * @memberof Query
     */
    query: string;
    /**
     * 
     * @type {QuerySpecification}
     * @memberof Query
     */
    spec?: QuerySpecification;
    /**
     * type of query
     * @type {string}
     * @memberof Query
     */
    type?: Query.TypeEnum;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    db?: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    rp?: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    cluster?: string;
    /**
     * 
     * @type {Dialect}
     * @memberof Query
     */
    dialect?: Dialect;
}

/**
 * @export
 * @namespace Query
 */
export namespace Query {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Flux = 'flux',
        Influxql = 'influxql'
    }
}

/**
 * 
 * @export
 * @interface QueryConfig
 */
export interface QueryConfig {
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    database: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    measurement: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    retentionPolicy: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryConfig
     */
    areTagsAccepted: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    rawText?: string;
    /**
     * 
     * @type {any}
     * @memberof QueryConfig
     */
    tags: any;
    /**
     * 
     * @type {QueryConfigGroupBy}
     * @memberof QueryConfig
     */
    groupBy: QueryConfigGroupBy;
    /**
     * 
     * @type {Array<Field>}
     * @memberof QueryConfig
     */
    fields: Array<Field>;
    /**
     * 
     * @type {QueryConfigRange}
     * @memberof QueryConfig
     */
    range?: QueryConfigRange;
}

/**
 * 
 * @export
 * @interface QueryConfigGroupBy
 */
export interface QueryConfigGroupBy {
    /**
     * 
     * @type {string}
     * @memberof QueryConfigGroupBy
     */
    time: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryConfigGroupBy
     */
    tags: Array<string>;
}

/**
 * 
 * @export
 * @interface QueryConfigRange
 */
export interface QueryConfigRange {
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    lower: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    upper: string;
}

/**
 * 
 * @export
 * @interface QueryMacroProperties
 */
export interface QueryMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    type?: QueryMacroProperties.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    queryType?: string;
}

/**
 * @export
 * @namespace QueryMacroProperties
 */
export namespace QueryMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Query = 'query'
    }
}

/**
 * consists of a set of operations and a set of edges between those operations to instruct the query engine to operate.
 * @export
 * @interface QuerySpecification
 */
export interface QuerySpecification {
    /**
     * 
     * @type {Array<QuerySpecificationOperations>}
     * @memberof QuerySpecification
     */
    operations?: Array<QuerySpecificationOperations>;
    /**
     * list of declaring a parent child id relationship between operations
     * @type {Array<QuerySpecificationEdges>}
     * @memberof QuerySpecification
     */
    edges?: Array<QuerySpecificationEdges>;
    /**
     * 
     * @type {QuerySpecificationResources}
     * @memberof QuerySpecification
     */
    resources?: QuerySpecificationResources;
    /**
     * 
     * @type {Dialect}
     * @memberof QuerySpecification
     */
    dialect?: Dialect;
}

/**
 * 
 * @export
 * @interface QuerySpecificationEdges
 */
export interface QuerySpecificationEdges {
    /**
     * id of parent node of child within graph of opertions
     * @type {string}
     * @memberof QuerySpecificationEdges
     */
    parent?: string;
    /**
     * id of child node of parent within the graph of operations
     * @type {string}
     * @memberof QuerySpecificationEdges
     */
    child?: string;
}

/**
 * 
 * @export
 * @interface QuerySpecificationOperations
 */
export interface QuerySpecificationOperations {
    /**
     * name of the operation to perform
     * @type {string}
     * @memberof QuerySpecificationOperations
     */
    kind?: string;
    /**
     * identifier for this operation; it must be unique per query specification; used in edges
     * @type {string}
     * @memberof QuerySpecificationOperations
     */
    id?: string;
    /**
     * set of properties that specify details of the operation. These vary by the kind of operation.
     * @type {any}
     * @memberof QuerySpecificationOperations
     */
    spec?: any;
}

/**
 * optional set of contraints on the resources the query can consume
 * @export
 * @interface QuerySpecificationResources
 */
export interface QuerySpecificationResources {
    /**
     * priority of the query
     * @type {any}
     * @memberof QuerySpecificationResources
     */
    priority?: any;
    /**
     * number of concurrent workers allowed to process this query; 0 indicates the planner can pick the optimal concurrency.
     * @type {number}
     * @memberof QuerySpecificationResources
     */
    concurrencyQuota?: number;
    /**
     * number of bytes of RAM this query may consume; 0 means unlimited.
     * @type {number}
     * @memberof QuerySpecificationResources
     */
    memoryBytesQuota?: number;
}

/**
 * Describes a field that can be renamed and made visible or invisible
 * @export
 * @interface RenamableField
 */
export interface RenamableField {
    /**
     * This is the calculated name of a field
     * @type {string}
     * @memberof RenamableField
     */
    internalName?: string;
    /**
     * This is the name that a field is renamed to by the user
     * @type {string}
     * @memberof RenamableField
     */
    displayName?: string;
    /**
     * Indicates whether this field should be visible on the table
     * @type {boolean}
     * @memberof RenamableField
     */
    visible?: boolean;
}

/**
 * 
 * @export
 * @interface ResourceOwner
 */
export interface ResourceOwner extends User {
    /**
     * 
     * @type {string}
     * @memberof ResourceOwner
     */
    role?: ResourceOwner.RoleEnum;
}

/**
 * @export
 * @namespace ResourceOwner
 */
export namespace ResourceOwner {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Owner = 'owner'
    }
}

/**
 * 
 * @export
 * @interface ResourceOwners
 */
export interface ResourceOwners {
    /**
     * 
     * @type {ResourceOwnersLinks}
     * @memberof ResourceOwners
     */
    links?: ResourceOwnersLinks;
    /**
     * 
     * @type {Array<ResourceOwner>}
     * @memberof ResourceOwners
     */
    users?: Array<ResourceOwner>;
}

/**
 * 
 * @export
 * @interface ResourceOwnersLinks
 */
export interface ResourceOwnersLinks {
    /**
     * 
     * @type {string}
     * @memberof ResourceOwnersLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface Routes
 */
export interface Routes {
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    sources?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    dashboards?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    write?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    orgs?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    auths?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    buckets?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    users?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    tasks?: string;
    /**
     * 
     * @type {RoutesSystem}
     * @memberof Routes
     */
    system?: RoutesSystem;
    /**
     * 
     * @type {RoutesExternal}
     * @memberof Routes
     */
    external?: RoutesExternal;
    /**
     * 
     * @type {FluxLinks}
     * @memberof Routes
     */
    flux?: FluxLinks;
}

/**
 * 
 * @export
 * @interface RoutesExternal
 */
export interface RoutesExternal {
    /**
     * 
     * @type {string}
     * @memberof RoutesExternal
     */
    statusFeed?: string;
}

/**
 * 
 * @export
 * @interface RoutesSystem
 */
export interface RoutesSystem {
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    metrics?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    debug?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    health?: string;
}

/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    taskID?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    status?: Run.StatusEnum;
    /**
     * Time used for run's \"now\" option, RFC3339.
     * @type {Date}
     * @memberof Run
     */
    scheduledFor?: Date;
    /**
     * Time run started executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    startedAt?: Date;
    /**
     * Time run finished executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    finishedAt?: Date;
    /**
     * Time run was manually requested, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    requestedAt?: Date;
    /**
     * 
     * @type {Error}
     * @memberof Run
     */
    error?: Error;
    /**
     * Link to the full logs for a run.
     * @type {string}
     * @memberof Run
     */
    log?: string;
}

/**
 * @export
 * @namespace Run
 */
export namespace Run {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Scheduled = 'scheduled',
        Executing = 'executing',
        Failed = 'failed',
        Success = 'success'
    }
}

/**
 * 
 * @export
 * @interface ScraperTargetRequest
 */
export interface ScraperTargetRequest {
    /**
     * name of the scraper target
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    name?: string;
    /**
     * type of the metrics to be parsed
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    type?: ScraperTargetRequest.TypeEnum;
    /**
     * url of the metrics endpoint
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    url?: string;
    /**
     * id of the organization
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    orgID?: string;
    /**
     * id of the bucket to be written
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    bucketID?: string;
}

/**
 * @export
 * @namespace ScraperTargetRequest
 */
export namespace ScraperTargetRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Prometheus = 'prometheus'
    }
}

/**
 * 
 * @export
 * @interface ScraperTargetResponse
 */
export interface ScraperTargetResponse extends ScraperTargetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    id?: string;
    /**
     * name of the organization
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    organization?: string;
    /**
     * name of the bucket
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    bucket?: string;
    /**
     * 
     * @type {Links}
     * @memberof ScraperTargetResponse
     */
    links?: Links;
}

/**
 * @export
 * @namespace ScraperTargetResponse
 */
export namespace ScraperTargetResponse {
}

/**
 * 
 * @export
 * @interface ScraperTargetResponses
 */
export interface ScraperTargetResponses {
    /**
     * 
     * @type {Array<ScraperTargetResponse>}
     * @memberof ScraperTargetResponses
     */
    configurations?: Array<ScraperTargetResponse>;
}

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {SourceLinks}
     * @memberof Source
     */
    links?: SourceLinks;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    orgID?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    type?: Source.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Source
     */
    insecureSkipVerify?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    telegraf?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    sharedSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    metaUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    defaultRP?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Source
     */
    languages?: Array<Source.LanguagesEnum>;
}

/**
 * @export
 * @namespace Source
 */
export namespace Source {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        V1 = 'v1',
        V2 = 'v2',
        Self = 'self'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LanguagesEnum {
        Flux = 'flux',
        Influxql = 'influxql',
        Spec = 'spec'
    }
}

/**
 * 
 * @export
 * @interface SourceLinks
 */
export interface SourceLinks {
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    health?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    buckets?: string;
}

/**
 * 
 * @export
 * @interface Sources
 */
export interface Sources {
    /**
     * 
     * @type {ResourceOwnersLinks}
     * @memberof Sources
     */
    links?: ResourceOwnersLinks;
    /**
     * 
     * @type {Array<Source>}
     * @memberof Sources
     */
    sources?: Array<Source>;
}

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof Task
     */
    orgID?: string;
    /**
     * A description of the task.
     * @type {string}
     * @memberof Task
     */
    name: string;
    /**
     * The current status of the task. When updated to 'inactive', cancels all queued jobs of this task.
     * @type {string}
     * @memberof Task
     */
    status?: Task.StatusEnum;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    owner?: User;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Task
     */
    labels?: Array<Label>;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof Task
     */
    flux: string;
    /**
     * A simple task repetition schedule; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    every?: string;
    /**
     * A task repetition schedule in the form '* * * * * *'; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    cron?: string;
    /**
     * Duration to delay after the schedule, before executing the task; parsed from flux.
     * @type {string}
     * @memberof Task
     */
    offset?: string;
    /**
     * Timestamp of latest scheduled, completed run, RFC3339.
     * @type {Date}
     * @memberof Task
     */
    latestCompleted?: Date;
    /**
     * 
     * @type {TaskLinks}
     * @memberof Task
     */
    links?: TaskLinks;
}

/**
 * @export
 * @namespace Task
 */
export namespace Task {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskCreateRequest
 */
export interface TaskCreateRequest {
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    orgID: string;
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskCreateRequest
     */
    status?: TaskCreateRequest.StatusEnum;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    flux: string;
}

/**
 * @export
 * @namespace TaskCreateRequest
 */
export namespace TaskCreateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskLinks
 */
export interface TaskLinks {
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    owners?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    members?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    runs?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    logs?: string;
}

/**
 * 
 * @export
 * @interface TaskUpdateRequest
 */
export interface TaskUpdateRequest {
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    status?: TaskUpdateRequest.StatusEnum;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    flux?: string;
}

/**
 * @export
 * @namespace TaskUpdateRequest
 */
export namespace TaskUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface Telegraf
 */
export interface Telegraf extends TelegrafRequest {
    /**
     * 
     * @type {string}
     * @memberof Telegraf
     */
    id?: string;
    /**
     * 
     * @type {any}
     * @memberof Telegraf
     */
    links?: any;
    /**
     * 
     * @type {Owners}
     * @memberof Telegraf
     */
    owners?: Owners;
}

/**
 * 
 * @export
 * @interface TelegrafPluginConfig
 */
export interface TelegrafPluginConfig {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputCpu
 */
export interface TelegrafPluginInputCpu {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    name: TelegrafPluginInputCpu.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    type: TelegrafPluginInputCpu.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputCpu
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputCpu
 */
export namespace TelegrafPluginInputCpu {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Cpu = 'cpu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputCpuRequest
 */
export interface TelegrafPluginInputCpuRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputCpuRequest
 */
export namespace TelegrafPluginInputCpuRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDisk
 */
export interface TelegrafPluginInputDisk {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    name: TelegrafPluginInputDisk.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    type: TelegrafPluginInputDisk.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputDisk
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputDisk
 */
export namespace TelegrafPluginInputDisk {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Disk = 'disk'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDiskRequest
 */
export interface TelegrafPluginInputDiskRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputDiskRequest
 */
export namespace TelegrafPluginInputDiskRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDiskio
 */
export interface TelegrafPluginInputDiskio {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    name: TelegrafPluginInputDiskio.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    type: TelegrafPluginInputDiskio.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputDiskio
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputDiskio
 */
export namespace TelegrafPluginInputDiskio {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Diskio = 'diskio'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDiskioRequest
 */
export interface TelegrafPluginInputDiskioRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputDiskioRequest
 */
export namespace TelegrafPluginInputDiskioRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDocker
 */
export interface TelegrafPluginInputDocker {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    name: TelegrafPluginInputDocker.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    type: TelegrafPluginInputDocker.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputDockerConfig}
     * @memberof TelegrafPluginInputDocker
     */
    config: TelegrafPluginInputDockerConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputDocker
 */
export namespace TelegrafPluginInputDocker {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Docker = 'docker'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDockerConfig
 */
export interface TelegrafPluginInputDockerConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDockerConfig
     */
    endpoint: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDockerRequest
 */
export interface TelegrafPluginInputDockerRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputDockerRequest
 */
export namespace TelegrafPluginInputDockerRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFile
 */
export interface TelegrafPluginInputFile {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    name: TelegrafPluginInputFile.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    type: TelegrafPluginInputFile.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputFileConfig}
     * @memberof TelegrafPluginInputFile
     */
    config: TelegrafPluginInputFileConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputFile
 */
export namespace TelegrafPluginInputFile {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        File = 'file'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFileConfig
 */
export interface TelegrafPluginInputFileConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputFileConfig
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFileRequest
 */
export interface TelegrafPluginInputFileRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputFileRequest
 */
export namespace TelegrafPluginInputFileRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKernel
 */
export interface TelegrafPluginInputKernel {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    name: TelegrafPluginInputKernel.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    type: TelegrafPluginInputKernel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputKernel
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputKernel
 */
export namespace TelegrafPluginInputKernel {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Kernel = 'kernel'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKernelRequest
 */
export interface TelegrafPluginInputKernelRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputKernelRequest
 */
export namespace TelegrafPluginInputKernelRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetes
 */
export interface TelegrafPluginInputKubernetes {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    name: TelegrafPluginInputKubernetes.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    type: TelegrafPluginInputKubernetes.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputKubernetesConfig}
     * @memberof TelegrafPluginInputKubernetes
     */
    config: TelegrafPluginInputKubernetesConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputKubernetes
 */
export namespace TelegrafPluginInputKubernetes {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Kubernetes = 'kubernetes'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetesConfig
 */
export interface TelegrafPluginInputKubernetesConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetesConfig
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetesRequest
 */
export interface TelegrafPluginInputKubernetesRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputKubernetesRequest
 */
export namespace TelegrafPluginInputKubernetesRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParser
 */
export interface TelegrafPluginInputLogParser {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    name: TelegrafPluginInputLogParser.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    type: TelegrafPluginInputLogParser.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputLogParserConfig}
     * @memberof TelegrafPluginInputLogParser
     */
    config: TelegrafPluginInputLogParserConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputLogParser
 */
export namespace TelegrafPluginInputLogParser {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Logparser = 'logparser'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParserConfig
 */
export interface TelegrafPluginInputLogParserConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputLogParserConfig
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParserRequest
 */
export interface TelegrafPluginInputLogParserRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputLogParserRequest
 */
export namespace TelegrafPluginInputLogParserRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputMem
 */
export interface TelegrafPluginInputMem {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    name: TelegrafPluginInputMem.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    type: TelegrafPluginInputMem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputMem
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputMem
 */
export namespace TelegrafPluginInputMem {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Mem = 'mem'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputMemRequest
 */
export interface TelegrafPluginInputMemRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputMemRequest
 */
export namespace TelegrafPluginInputMemRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNet
 */
export interface TelegrafPluginInputNet {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    name: TelegrafPluginInputNet.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    type: TelegrafPluginInputNet.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputNet
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputNet
 */
export namespace TelegrafPluginInputNet {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Net = 'net'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNetRequest
 */
export interface TelegrafPluginInputNetRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputNetRequest
 */
export namespace TelegrafPluginInputNetRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNetResponse
 */
export interface TelegrafPluginInputNetResponse {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    name: TelegrafPluginInputNetResponse.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    type: TelegrafPluginInputNetResponse.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputNetResponse
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputNetResponse
 */
export namespace TelegrafPluginInputNetResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        NetResponse = 'net_response'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNetResponseRequest
 */
export interface TelegrafPluginInputNetResponseRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputNetResponseRequest
 */
export namespace TelegrafPluginInputNetResponseRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNginx
 */
export interface TelegrafPluginInputNginx {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    name: TelegrafPluginInputNginx.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    type: TelegrafPluginInputNginx.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputNginx
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputNginx
 */
export namespace TelegrafPluginInputNginx {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Nginx = 'nginx'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNginxRequest
 */
export interface TelegrafPluginInputNginxRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputNginxRequest
 */
export namespace TelegrafPluginInputNginxRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcesses
 */
export interface TelegrafPluginInputProcesses {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    name: TelegrafPluginInputProcesses.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    type: TelegrafPluginInputProcesses.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputProcesses
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputProcesses
 */
export namespace TelegrafPluginInputProcesses {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Processes = 'processes'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcessesRequest
 */
export interface TelegrafPluginInputProcessesRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputProcessesRequest
 */
export namespace TelegrafPluginInputProcessesRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstat
 */
export interface TelegrafPluginInputProcstat {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    name: TelegrafPluginInputProcstat.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    type: TelegrafPluginInputProcstat.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputProcstatConfig}
     * @memberof TelegrafPluginInputProcstat
     */
    config: TelegrafPluginInputProcstatConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputProcstat
 */
export namespace TelegrafPluginInputProcstat {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Procstat = 'procstat'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstatConfig
 */
export interface TelegrafPluginInputProcstatConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstatConfig
     */
    exe?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstatRequest
 */
export interface TelegrafPluginInputProcstatRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputProcstatRequest
 */
export namespace TelegrafPluginInputProcstatRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheus
 */
export interface TelegrafPluginInputPrometheus {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    name: TelegrafPluginInputPrometheus.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    type: TelegrafPluginInputPrometheus.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputPrometheusConfig}
     * @memberof TelegrafPluginInputPrometheus
     */
    config: TelegrafPluginInputPrometheusConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputPrometheus
 */
export namespace TelegrafPluginInputPrometheus {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Prometheus = 'prometheus'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheusConfig
 */
export interface TelegrafPluginInputPrometheusConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputPrometheusConfig
     */
    urls?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheusRequest
 */
export interface TelegrafPluginInputPrometheusRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputPrometheusRequest
 */
export namespace TelegrafPluginInputPrometheusRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedis
 */
export interface TelegrafPluginInputRedis {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    name: TelegrafPluginInputRedis.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    type: TelegrafPluginInputRedis.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputRedisConfig}
     * @memberof TelegrafPluginInputRedis
     */
    config: TelegrafPluginInputRedisConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputRedis
 */
export namespace TelegrafPluginInputRedis {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Redis = 'redis'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedisConfig
 */
export interface TelegrafPluginInputRedisConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputRedisConfig
     */
    servers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedisConfig
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedisRequest
 */
export interface TelegrafPluginInputRedisRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputRedisRequest
 */
export namespace TelegrafPluginInputRedisRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSwap
 */
export interface TelegrafPluginInputSwap {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    name: TelegrafPluginInputSwap.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    type: TelegrafPluginInputSwap.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputSwap
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputSwap
 */
export namespace TelegrafPluginInputSwap {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Swap = 'swap'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSwapRequest
 */
export interface TelegrafPluginInputSwapRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputSwapRequest
 */
export namespace TelegrafPluginInputSwapRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslog
 */
export interface TelegrafPluginInputSyslog {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    name: TelegrafPluginInputSyslog.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    type: TelegrafPluginInputSyslog.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputSyslogConfig}
     * @memberof TelegrafPluginInputSyslog
     */
    config: TelegrafPluginInputSyslogConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputSyslog
 */
export namespace TelegrafPluginInputSyslog {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Syslog = 'syslog'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslogConfig
 */
export interface TelegrafPluginInputSyslogConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslogConfig
     */
    server?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslogRequest
 */
export interface TelegrafPluginInputSyslogRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputSyslogRequest
 */
export namespace TelegrafPluginInputSyslogRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSystem
 */
export interface TelegrafPluginInputSystem {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    name: TelegrafPluginInputSystem.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    type: TelegrafPluginInputSystem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputSystem
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputSystem
 */
export namespace TelegrafPluginInputSystem {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        System = 'system'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSystemRequest
 */
export interface TelegrafPluginInputSystemRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputSystemRequest
 */
export namespace TelegrafPluginInputSystemRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputTail
 */
export interface TelegrafPluginInputTail {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    name: TelegrafPluginInputTail.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    type: TelegrafPluginInputTail.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginConfig}
     * @memberof TelegrafPluginInputTail
     */
    config: TelegrafPluginConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputTail
 */
export namespace TelegrafPluginInputTail {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Tail = 'tail'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputTailRequest
 */
export interface TelegrafPluginInputTailRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginInputTailRequest
 */
export namespace TelegrafPluginInputTailRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFile
 */
export interface TelegrafPluginOutputFile {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    name: TelegrafPluginOutputFile.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    type: TelegrafPluginOutputFile.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginOutputFileConfig}
     * @memberof TelegrafPluginOutputFile
     */
    config: TelegrafPluginOutputFileConfig;
}

/**
 * @export
 * @namespace TelegrafPluginOutputFile
 */
export namespace TelegrafPluginOutputFile {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        File = 'file'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Output = 'output'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileConfig
 */
export interface TelegrafPluginOutputFileConfig {
    /**
     * 
     * @type {Array<TelegrafPluginOutputFileConfigFiles>}
     * @memberof TelegrafPluginOutputFileConfig
     */
    files: Array<TelegrafPluginOutputFileConfigFiles>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileConfigFiles
 */
export interface TelegrafPluginOutputFileConfigFiles {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileConfigFiles
     */
    type?: TelegrafPluginOutputFileConfigFiles.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileConfigFiles
     */
    path?: string;
}

/**
 * @export
 * @namespace TelegrafPluginOutputFileConfigFiles
 */
export namespace TelegrafPluginOutputFileConfigFiles {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Stdout = 'stdout',
        Path = 'path'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileRequest
 */
export interface TelegrafPluginOutputFileRequest extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginOutputFileRequest
 */
export namespace TelegrafPluginOutputFileRequest {
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2
 */
export interface TelegrafPluginOutputInfluxDBV2 {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    name: TelegrafPluginOutputInfluxDBV2.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    type: TelegrafPluginOutputInfluxDBV2.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginOutputInfluxDBV2Config}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    config: TelegrafPluginOutputInfluxDBV2Config;
}

/**
 * @export
 * @namespace TelegrafPluginOutputInfluxDBV2
 */
export namespace TelegrafPluginOutputInfluxDBV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        InfluxdbV2 = 'influxdb_v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Output = 'output'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2Config
 */
export interface TelegrafPluginOutputInfluxDBV2Config {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    urls: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    organization: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    bucket: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2Request
 */
export interface TelegrafPluginOutputInfluxDBV2Request extends TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafPluginOutputInfluxDBV2Request
 */
export namespace TelegrafPluginOutputInfluxDBV2Request {
}

/**
 * 
 * @export
 * @interface TelegrafRequest
 */
export interface TelegrafRequest {
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    name?: string;
    /**
     * 
     * @type {TelegrafRequestAgent}
     * @memberof TelegrafRequest
     */
    agent?: TelegrafRequestAgent;
    /**
     * 
     * @type {Array<TelegrafRequestPlugin>}
     * @memberof TelegrafRequest
     */
    plugins?: Array<TelegrafRequestPlugin>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    organizationID?: string;
}

/**
 * 
 * @export
 * @interface TelegrafRequestAgent
 */
export interface TelegrafRequestAgent {
    /**
     * 
     * @type {number}
     * @memberof TelegrafRequestAgent
     */
    collectionInterval?: number;
}

/**
 * 
 * @export
 * @interface TelegrafRequestConfig
 */
export interface TelegrafRequestConfig {
}

/**
 * 
 * @export
 * @interface TelegrafRequestPlugin
 */
export interface TelegrafRequestPlugin {
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequestPlugin
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Telegrafs
 */
export interface Telegrafs {
    /**
     * 
     * @type {Array<Telegraf>}
     * @memberof Telegrafs
     */
    configurations?: Array<Telegraf>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * if inactive the user is inactive.
     * @type {string}
     * @memberof User
     */
    status?: User.StatusEnum;
    /**
     * 
     * @type {ResourceOwnersLinks}
     * @memberof User
     */
    links?: ResourceOwnersLinks;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {ResourceOwnersLinks}
     * @memberof Users
     */
    links?: ResourceOwnersLinks;
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    users?: Array<User>;
}

/**
 * 
 * @export
 * @interface V1ViewProperties
 */
export interface V1ViewProperties {
    /**
     * 
     * @type {string}
     * @memberof V1ViewProperties
     */
    type?: V1ViewProperties.TypeEnum;
    /**
     * 
     * @type {Array<DashboardQuery>}
     * @memberof V1ViewProperties
     */
    queries?: Array<DashboardQuery>;
    /**
     * 
     * @type {V1ViewPropertiesAxes}
     * @memberof V1ViewProperties
     */
    axes?: V1ViewPropertiesAxes;
    /**
     * The viewport for a view's graph/visualization
     * @type {string}
     * @memberof V1ViewProperties
     */
    graphType?: V1ViewProperties.GraphTypeEnum;
    /**
     * Colors define color encoding of data into a visualization
     * @type {Array<DashboardColor>}
     * @memberof V1ViewProperties
     */
    colors?: Array<DashboardColor>;
    /**
     * 
     * @type {V1ViewPropertiesLegend}
     * @memberof V1ViewProperties
     */
    legend?: V1ViewPropertiesLegend;
    /**
     * 
     * @type {any}
     * @memberof V1ViewProperties
     */
    tableOptions?: any;
    /**
     * fieldOptions represent the fields retrieved by the query with customization options
     * @type {Array<RenamableField>}
     * @memberof V1ViewProperties
     */
    fieldOptions?: Array<RenamableField>;
    /**
     * timeFormat describes the display format for time values according to moment.js date formatting
     * @type {string}
     * @memberof V1ViewProperties
     */
    timeFormat?: string;
    /**
     * 
     * @type {V1ViewPropertiesDecimalPoints}
     * @memberof V1ViewProperties
     */
    decimalPoints?: V1ViewPropertiesDecimalPoints;
}

/**
 * @export
 * @namespace V1ViewProperties
 */
export namespace V1ViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ChronografV1 = 'chronograf-v1'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GraphTypeEnum {
        SingleStat = 'single-stat',
        Line = 'line',
        LinePlusSingleStat = 'line-plus-single-stat',
        LineStacked = 'line-stacked',
        LineStepplot = 'line-stepplot',
        Bar = 'bar',
        Gauge = 'gauge',
        Table = 'table'
    }
}

/**
 * The viewport for a View's visualizations
 * @export
 * @interface V1ViewPropertiesAxes
 */
export interface V1ViewPropertiesAxes {
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    x?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    y?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    y2?: Axis;
}

/**
 * decimal points indicates whether and how many digits to show after decimal point
 * @export
 * @interface V1ViewPropertiesDecimalPoints
 */
export interface V1ViewPropertiesDecimalPoints {
    /**
     * Indicates whether decimal point setting should be enforced
     * @type {boolean}
     * @memberof V1ViewPropertiesDecimalPoints
     */
    isEnforced?: boolean;
    /**
     * The number of digists after decimal to display
     * @type {number}
     * @memberof V1ViewPropertiesDecimalPoints
     */
    digits?: number;
}

/**
 * Legend define encoding of data into a view's legend
 * @export
 * @interface V1ViewPropertiesLegend
 */
export interface V1ViewPropertiesLegend {
    /**
     * type is the style of the legend
     * @type {string}
     * @memberof V1ViewPropertiesLegend
     */
    type?: V1ViewPropertiesLegend.TypeEnum;
    /**
     * orientation is the location of the legend with respect to the view graph
     * @type {string}
     * @memberof V1ViewPropertiesLegend
     */
    orientation?: V1ViewPropertiesLegend.OrientationEnum;
}

/**
 * @export
 * @namespace V1ViewPropertiesLegend
 */
export namespace V1ViewPropertiesLegend {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Static = 'static'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OrientationEnum {
        Top = 'top',
        Bottom = 'bottom',
        Left = 'left',
        Right = 'right'
    }
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {ViewLinks}
     * @memberof View
     */
    links?: ViewLinks;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof View
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface ViewLinks
 */
export interface ViewLinks {
    /**
     * 
     * @type {string}
     * @memberof ViewLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface Views
 */
export interface Views {
    /**
     * 
     * @type {ViewLinks}
     * @memberof Views
     */
    links?: ViewLinks;
    /**
     * 
     * @type {Array<View>}
     * @memberof Views
     */
    views?: Array<View>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WritePrecision {
    Ms = 'ms',
    S = 's',
    Us = 'us',
    U = 'u',
    Ns = 'ns'
}


/**
 * AuthorizationsApi - axios parameter creator
 * @export
 */
export const AuthorizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDDelete.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDGet.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDPatch.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling authorizationsAuthIDPatch.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Authorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorization || {}) : (authorization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options: any = {}): RequestArgs {
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userID !== undefined) {
                localVarQueryParameter['userID'] = userID;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling authorizationsPost.');
            }
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Authorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorization || {}) : (authorization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationsApi - functional programming interface
 * @export
 */
export const AuthorizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDDelete(authID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDGet(authID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDPatch(authID, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorizations> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsGet(userID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsPost(authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthorizationsApi - factory interface
 * @export
 */
export const AuthorizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDDelete(authID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDGet(authID, options)(axios, basePath);
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDPatch(authID, authorization, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsGet(userID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsPost(authorization, options)(axios, basePath);
        },
    };
};

/**
 * AuthorizationsApi - object-oriented interface
 * @export
 * @class AuthorizationsApi
 * @extends {BaseAPI}
 */
export class AuthorizationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a authorization
     * @param {string} authID ID of authorization to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDDelete(authID: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDDelete(authID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an authorization
     * @param {string} authID ID of authorization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDGet(authID: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDGet(authID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
     * @param {string} authID ID of authorization to update
     * @param {Authorization} authorization authorization to update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDPatch(authID, authorization, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all authorizations
     * @param {string} [userID] filter authorizations belonging to a user id
     * @param {string} [user] filter authorizations belonging to a user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsGet(userID?: string, user?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsGet(userID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an authorization
     * @param {Authorization} authorization authorization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsPost(authorization: Authorization, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsPost(authorization, options)(this.axios, this.basePath);
    }

}

/**
 * BucketsApi - axios parameter creator
 * @export
 */
export const BucketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDDelete(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDGet.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsGet(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDLabelsGet.');
            }
            const localVarPath = `/buckets/{bucketID}/labels`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a bucket config
         * @param {string} bucketID ID of the bucket config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsLabelIDDelete(bucketID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling bucketsBucketIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/labels/{labelID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsPost(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling bucketsBucketIDLabelsPost.');
            }
            const localVarPath = `/buckets/{bucketID}/labels`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDPatch.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling bucketsBucketIDPatch.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bucketsGet.');
            }
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bucketsPost.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling bucketsPost.');
            }
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BucketsApi - functional programming interface
 * @export
 */
export const BucketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDDelete(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDDelete(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsGet(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDLabelsGet(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a bucket config
         * @param {string} bucketID ID of the bucket config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsLabelIDDelete(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDLabelsLabelIDDelete(bucketID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsPost(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDLabelsPost(bucketID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDPatch(bucketID, bucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsPost(org, bucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).sourcesSourceIDBucketsGet(sourceID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * BucketsApi - factory interface
 * @export
 */
export const BucketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDDelete(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDDelete(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsGet(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDLabelsGet(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a bucket config
         * @param {string} bucketID ID of the bucket config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsLabelIDDelete(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDLabelsLabelIDDelete(bucketID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDLabelsPost(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDLabelsPost(bucketID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDPatch(bucketID, bucket, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options?: any) {
            return BucketsApiFp(configuration).bucketsGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options?: any) {
            return BucketsApiFp(configuration).bucketsPost(org, bucket, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
            return BucketsApiFp(configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(axios, basePath);
        },
    };
};

/**
 * BucketsApi - object-oriented interface
 * @export
 * @class BucketsApi
 * @extends {BaseAPI}
 */
export class BucketsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a bucket
     * @param {string} bucketID ID of bucket to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDDelete(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDDelete(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a bucket
     * @param {string} bucketID ID of bucket to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDLabelsGet(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDLabelsGet(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a bucket config
     * @param {string} bucketID ID of the bucket config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDLabelsLabelIDDelete(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDLabelsLabelIDDelete(bucketID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a bucket
     * @param {string} bucketID ID of the bucket
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDLabelsPost(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDLabelsPost(bucketID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a bucket
     * @param {string} bucketID ID of bucket to update
     * @param {Bucket} bucket bucket update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDPatch(bucketID, bucket, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all buckets
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsGet(org: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a bucket
     * @param {string} org specifies the organization of the resource
     * @param {Bucket} bucket bucket to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsPost(org: string, bucket: Bucket, options?: any) {
        return BucketsApiFp(this.configuration).bucketsPost(org, bucket, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
        return BucketsApiFp(this.configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(this.axios, this.basePath);
    }

}

/**
 * CellsApi - axios parameter creator
 * @export
 */
export const CellsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellsApi - functional programming interface
 * @export
 */
export const CellsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CellsApi - factory interface
 * @export
 */
export const CellsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(axios, basePath);
        },
    };
};

/**
 * CellsApi - object-oriented interface
 * @export
 * @class CellsApi
 * @extends {BaseAPI}
 */
export class CellsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(this.axios, this.basePath);
    }

}

/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsGet(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDLabelsGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a dashboard config
         * @param {string} dashboardID ID of the dashboard config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDDelete(dashboardID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling dashboardsDashboardIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels/{labelID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDLabelsLabelIDPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling dashboardsDashboardIDLabelsLabelIDPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels/{labelID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling dashboardsDashboardIDLabelsPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDPatch.');
            }
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling dashboardsDashboardIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(org?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(dashboard: Dashboard, options: any = {}): RequestArgs {
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling dashboardsPost.');
            }
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDDelete(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsGet(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDLabelsGet(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a dashboard config
         * @param {string} dashboardID ID of the dashboard config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDDelete(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDLabelsLabelIDDelete(dashboardID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDLabelsLabelIDPost(dashboardID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDLabelsPost(dashboardID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(org?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboards> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsGet(org, owner, sortBy, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(dashboard: Dashboard, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsPost(dashboard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDDelete(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsGet(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDLabelsGet(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a dashboard config
         * @param {string} dashboardID ID of the dashboard config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDDelete(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDLabelsLabelIDDelete(dashboardID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsLabelIDPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDLabelsLabelIDPost(dashboardID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDLabelsPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDLabelsPost(dashboardID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(org?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any) {
            return DashboardsApiFp(configuration).dashboardsGet(org, owner, sortBy, id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(dashboard: Dashboard, options?: any) {
            return DashboardsApiFp(configuration).dashboardsPost(dashboard, options)(axios, basePath);
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDDelete(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDDelete(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a single Dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDLabelsGet(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDLabelsGet(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a dashboard config
     * @param {string} dashboardID ID of the dashboard config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDLabelsLabelIDDelete(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDLabelsLabelIDDelete(dashboardID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDLabelsLabelIDPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDLabelsLabelIDPost(dashboardID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDLabelsPost(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDLabelsPost(dashboardID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {Dashboard} dashboard patching of a dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all dashboards
     * @param {string} [org] specifies the organization name of the resource
     * @param {string} [owner] specifies the owner id to return resources for
     * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
     * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsGet(org?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsGet(org, owner, sortBy, id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard
     * @param {Dashboard} dashboard dashboard to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsPost(dashboard: Dashboard, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsPost(dashboard, options)(this.axios, this.basePath);
    }

}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options: any = {}): RequestArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options: any = {}): RequestArgs {
            const localVarPath = `/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options: any = {}): RequestArgs {
            const localVarPath = `/signout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Routes> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).rootGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).signinPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).signoutPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any) {
            return DefaultApiFp(configuration).rootGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options?: any) {
            return DefaultApiFp(configuration).signinPost(options)(axios, basePath);
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any) {
            return DefaultApiFp(configuration).signoutPost(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Map of all top level routes available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: any) {
        return DefaultApiFp(this.configuration).rootGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Exchange basic auth credentials for session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signinPost(options?: any) {
        return DefaultApiFp(this.configuration).signinPost(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Expire the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signoutPost(options?: any) {
        return DefaultApiFp(this.configuration).signoutPost(options)(this.axios, this.basePath);
    }

}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options: any = {}): RequestArgs {
            const localVarPath = `/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health> {
            const localVarAxiosArgs = HealthApiAxiosParamCreator(configuration).healthGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any) {
            return HealthApiFp(configuration).healthGet(options)(axios, basePath);
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Get the health of an instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthGet(options?: any) {
        return HealthApiFp(this.configuration).healthGet(options)(this.axios, this.basePath);
    }

}

/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsGet(options: any = {}): RequestArgs {
            const localVarPath = `/labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDDelete(labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling labelsLabelIDDelete.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDGet(labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling labelsLabelIDGet.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDPatch(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling labelsLabelIDPatch.');
            }
            // verify required parameter 'labelUpdate' is not null or undefined
            if (labelUpdate === null || labelUpdate === undefined) {
                throw new RequiredError('labelUpdate','Required parameter labelUpdate was null or undefined when calling labelsLabelIDPatch.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelUpdate || {}) : (labelUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {Label} label label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsPost(label: Label, options: any = {}): RequestArgs {
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling labelsPost.');
            }
            const localVarPath = `/labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Label" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(label || {}) : (label || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).labelsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDDelete(labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).labelsLabelIDDelete(labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDGet(labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).labelsLabelIDGet(labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDPatch(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).labelsLabelIDPatch(labelID, labelUpdate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {Label} label label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsPost(label: Label, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).labelsPost(label, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsGet(options?: any) {
            return LabelsApiFp(configuration).labelsGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDDelete(labelID: string, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).labelsLabelIDDelete(labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDGet(labelID: string, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).labelsLabelIDGet(labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsLabelIDPatch(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).labelsLabelIDPatch(labelID, labelUpdate, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a label
         * @param {Label} label label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsPost(label: Label, options?: any) {
            return LabelsApiFp(configuration).labelsPost(label, options)(axios, basePath);
        },
    };
};

/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
    /**
     * 
     * @summary Get all labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public labelsGet(options?: any) {
        return LabelsApiFp(this.configuration).labelsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a label
     * @param {string} labelID ID of label to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public labelsLabelIDDelete(labelID: string, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).labelsLabelIDDelete(labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a label
     * @param {string} labelID ID of label to update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public labelsLabelIDGet(labelID: string, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).labelsLabelIDGet(labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single label
     * @param {string} labelID ID of label to update
     * @param {LabelUpdate} labelUpdate label update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public labelsLabelIDPatch(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).labelsLabelIDPatch(labelID, labelUpdate, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a label
     * @param {Label} label label to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public labelsPost(label: Label, options?: any) {
        return LabelsApiFp(this.configuration).labelsPost(label, options)(this.axios, this.basePath);
    }

}

/**
 * MacrosApi - axios parameter creator
 * @export
 */
export const MacrosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosGet.');
            }
            const localVarPath = `/macros`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosMacroIDDelete.');
            }
            // verify required parameter 'macroID' is not null or undefined
            if (macroID === null || macroID === undefined) {
                throw new RequiredError('macroID','Required parameter macroID was null or undefined when calling macrosMacroIDDelete.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosMacroIDDelete.');
            }
            const localVarPath = `/macros/{macroID}`
                .replace(`{${"macroID"}}`, encodeURIComponent(String(macroID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosMacroIDPatch.');
            }
            // verify required parameter 'macroID' is not null or undefined
            if (macroID === null || macroID === undefined) {
                throw new RequiredError('macroID','Required parameter macroID was null or undefined when calling macrosMacroIDPatch.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosMacroIDPatch.');
            }
            const localVarPath = `/macros/{macroID}`
                .replace(`{${"macroID"}}`, encodeURIComponent(String(macroID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosPost.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosPost.');
            }
            const localVarPath = `/macros`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MacrosApi - functional programming interface
 * @export
 */
export const MacrosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosGet(authorization, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosMacroIDDelete(authorization, macroID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosMacroIDPatch(authorization, macroID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosPost(authorization, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * MacrosApi - factory interface
 * @export
 */
export const MacrosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosGet(authorization, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosMacroIDDelete(authorization, macroID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosMacroIDPatch(authorization, macroID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosPost(authorization, org, options)(axios, basePath);
        },
    };
};

/**
 * MacrosApi - object-oriented interface
 * @export
 * @class MacrosApi
 * @extends {BaseAPI}
 */
export class MacrosApi extends BaseAPI {
    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosGet(authorization: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosGet(authorization, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} macroID id of the macro
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosMacroIDDelete(authorization, macroID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} macroID id of the macro
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosMacroIDPatch(authorization, macroID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosPost(authorization: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosPost(authorization, org, options)(this.axios, this.basePath);
    }

}

/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options: any = {}): RequestArgs {
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDDelete(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDGet.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsGet(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDLabelsGet.');
            }
            const localVarPath = `/orgs/{orgID}/labels`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a org config
         * @param {string} orgID ID of the org config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsLabelIDDelete(orgID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling orgsOrgIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/labels/{labelID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsPost(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling orgsOrgIDLabelsPost.');
            }
            const localVarPath = `/orgs/{orgID}/labels`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersGet.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDMembersPost.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersGet.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDPatch.');
            }
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling orgsOrgIDPatch.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options: any = {}): RequestArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling orgsPost.');
            }
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organizations> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDDelete(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDDelete(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsGet(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDLabelsGet(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a org config
         * @param {string} orgID ID of the org config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsLabelIDDelete(orgID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDLabelsLabelIDDelete(orgID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsPost(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDLabelsPost(orgID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDPatch(orgID, organization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsPost(organization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any) {
            return OrganizationsApiFp(configuration).orgsGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary delete an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDDelete(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDDelete(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsGet(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDLabelsGet(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a org config
         * @param {string} orgID ID of the org config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsLabelIDDelete(orgID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDLabelsLabelIDDelete(orgID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDLabelsPost(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDLabelsPost(orgID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDPatch(orgID, organization, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options?: any) {
            return OrganizationsApiFp(configuration).orgsPost(organization, options)(axios, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary List all organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsGet(options?: any) {
        return OrganizationsApiFp(this.configuration).orgsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete an organization
     * @param {string} orgID ID of organization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDDelete(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDDelete(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an organization
     * @param {string} orgID ID of organization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDLabelsGet(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDLabelsGet(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a org config
     * @param {string} orgID ID of the org config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDLabelsLabelIDDelete(orgID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDLabelsLabelIDDelete(orgID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to an organization
     * @param {string} orgID ID of the organization
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDLabelsPost(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDLabelsPost(orgID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update an organization
     * @param {string} orgID ID of organization to get
     * @param {Organization} organization organization update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDPatch(orgID: string, organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDPatch(orgID, organization, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an organization
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsPost(organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsPost(organization, options)(this.axios, this.basePath);
    }

}

/**
 * ProtosApi - axios parameter creator
 * @export
 */
export const ProtosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of available protos (templates of tasks/dashboards/etc)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosGet(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/protos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create instance of a proto dashboard
         * @param {string} protoID ID of proto
         * @param {CreateProtoResourcesRequest} createProtoResourcesRequest organization that the dashboard will be created as
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosProtoIDDashboardsPost(protoID: string, createProtoResourcesRequest: CreateProtoResourcesRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'protoID' is not null or undefined
            if (protoID === null || protoID === undefined) {
                throw new RequiredError('protoID','Required parameter protoID was null or undefined when calling protosProtoIDDashboardsPost.');
            }
            // verify required parameter 'createProtoResourcesRequest' is not null or undefined
            if (createProtoResourcesRequest === null || createProtoResourcesRequest === undefined) {
                throw new RequiredError('createProtoResourcesRequest','Required parameter createProtoResourcesRequest was null or undefined when calling protosProtoIDDashboardsPost.');
            }
            const localVarPath = `/protos/{protoID}/dashboards`
                .replace(`{${"protoID"}}`, encodeURIComponent(String(protoID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateProtoResourcesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createProtoResourcesRequest || {}) : (createProtoResourcesRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProtosApi - functional programming interface
 * @export
 */
export const ProtosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of available protos (templates of tasks/dashboards/etc)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosGet(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Protos> {
            const localVarAxiosArgs = ProtosApiAxiosParamCreator(configuration).protosGet(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create instance of a proto dashboard
         * @param {string} protoID ID of proto
         * @param {CreateProtoResourcesRequest} createProtoResourcesRequest organization that the dashboard will be created as
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosProtoIDDashboardsPost(protoID: string, createProtoResourcesRequest: CreateProtoResourcesRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboards> {
            const localVarAxiosArgs = ProtosApiAxiosParamCreator(configuration).protosProtoIDDashboardsPost(protoID, createProtoResourcesRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ProtosApi - factory interface
 * @export
 */
export const ProtosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List of available protos (templates of tasks/dashboards/etc)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosGet(zapTraceSpan?: string, options?: any) {
            return ProtosApiFp(configuration).protosGet(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create instance of a proto dashboard
         * @param {string} protoID ID of proto
         * @param {CreateProtoResourcesRequest} createProtoResourcesRequest organization that the dashboard will be created as
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protosProtoIDDashboardsPost(protoID: string, createProtoResourcesRequest: CreateProtoResourcesRequest, zapTraceSpan?: string, options?: any) {
            return ProtosApiFp(configuration).protosProtoIDDashboardsPost(protoID, createProtoResourcesRequest, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * ProtosApi - object-oriented interface
 * @export
 * @class ProtosApi
 * @extends {BaseAPI}
 */
export class ProtosApi extends BaseAPI {
    /**
     * 
     * @summary List of available protos (templates of tasks/dashboards/etc)
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProtosApi
     */
    public protosGet(zapTraceSpan?: string, options?: any) {
        return ProtosApiFp(this.configuration).protosGet(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create instance of a proto dashboard
     * @param {string} protoID ID of proto
     * @param {CreateProtoResourcesRequest} createProtoResourcesRequest organization that the dashboard will be created as
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProtosApi
     */
    public protosProtoIDDashboardsPost(protoID: string, createProtoResourcesRequest: CreateProtoResourcesRequest, zapTraceSpan?: string, options?: any) {
        return ProtosApiFp(this.configuration).protosProtoIDDashboardsPost(protoID, createProtoResourcesRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAnalyzePost(contentType?: 'application/json', authorization?: string, query?: Query, options: any = {}): RequestArgs {
            const localVarPath = `/query/analyze`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/ast`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(languageRequest || {}) : (languageRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json' | 'application/vnd.flux', authorization?: string, org?: string, query?: Query, options: any = {}): RequestArgs {
            const localVarPath = `/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/spec`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(languageRequest || {}) : (languageRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options: any = {}): RequestArgs {
            const localVarPath = `/query/suggestions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling querySuggestionsNameGet.');
            }
            const localVarPath = `/query/suggestions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAnalyzePost(contentType?: 'application/json', authorization?: string, query?: Query, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeQueryResponse> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryAnalyzePost(contentType, authorization, query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ASTResponse> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryAstPost(contentType, authorization, languageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json' | 'application/vnd.flux', authorization?: string, org?: string, query?: Query, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryPost(accept, contentType, authorization, org, query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySpecification> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySpecPost(contentType, authorization, languageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySuggestionsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySuggestionsNameGet(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAnalyzePost(contentType?: 'application/json', authorization?: string, query?: Query, options?: any) {
            return QueryApiFp(configuration).queryAnalyzePost(contentType, authorization, query, options)(axios, basePath);
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
            return QueryApiFp(configuration).queryAstPost(contentType, authorization, languageRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json' | 'application/vnd.flux', authorization?: string, org?: string, query?: Query, options?: any) {
            return QueryApiFp(configuration).queryPost(accept, contentType, authorization, org, query, options)(axios, basePath);
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
            return QueryApiFp(configuration).querySpecPost(contentType, authorization, languageRequest, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options?: any) {
            return QueryApiFp(configuration).querySuggestionsGet(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options?: any) {
            return QueryApiFp(configuration).querySuggestionsNameGet(name, options)(axios, basePath);
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary analyze an influxql or flux query
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {Query} [query] flux or influxql query to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryAnalyzePost(contentType?: 'application/json', authorization?: string, query?: Query, options?: any) {
        return QueryApiFp(this.configuration).queryAnalyzePost(contentType, authorization, query, options)(this.axios, this.basePath);
    }

    /**
     * analyzes flux query and generates a query specification.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
        return QueryApiFp(this.configuration).queryAstPost(contentType, authorization, languageRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary query an influx
     * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
     * @param {'application/json' | 'application/vnd.flux'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} [org] specifies the name of the organization executing the query.
     * @param {Query} [query] flux query or specification to execute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json' | 'application/vnd.flux', authorization?: string, org?: string, query?: Query, options?: any) {
        return QueryApiFp(this.configuration).queryPost(accept, contentType, authorization, org, query, options)(this.axios, this.basePath);
    }

    /**
     * analyzes flux query and generates a query specification.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
        return QueryApiFp(this.configuration).querySpecPost(contentType, authorization, languageRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySuggestionsGet(options?: any) {
        return QueryApiFp(this.configuration).querySuggestionsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} name name of branching suggestion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySuggestionsNameGet(name: string, options?: any) {
        return QueryApiFp(this.configuration).querySuggestionsNameGet(name, options)(this.axios, this.basePath);
    }

}

/**
 * ScraperTargetsApi - axios parameter creator
 * @export
 */
export const ScraperTargetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get all scraper targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersGet(options: any = {}): RequestArgs {
            const localVarPath = `/scrapers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersPost(scraperTargetRequest: ScraperTargetRequest, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetRequest' is not null or undefined
            if (scraperTargetRequest === null || scraperTargetRequest === undefined) {
                throw new RequiredError('scraperTargetRequest','Required parameter scraperTargetRequest was null or undefined when calling scrapersPost.');
            }
            const localVarPath = `/scrapers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScraperTargetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scraperTargetRequest || {}) : (scraperTargetRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDDelete(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling scrapersScraperTargetIDDelete.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDPatch(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling scrapersScraperTargetIDPatch.');
            }
            // verify required parameter 'scraperTargetRequest' is not null or undefined
            if (scraperTargetRequest === null || scraperTargetRequest === undefined) {
                throw new RequiredError('scraperTargetRequest','Required parameter scraperTargetRequest was null or undefined when calling scrapersScraperTargetIDPatch.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScraperTargetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scraperTargetRequest || {}) : (scraperTargetRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScraperTargetsApi - functional programming interface
 * @export
 */
export const ScraperTargetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get all scraper targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponses> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).scrapersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersPost(scraperTargetRequest: ScraperTargetRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).scrapersPost(scraperTargetRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDDelete(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).scrapersScraperTargetIDDelete(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDPatch(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).scrapersScraperTargetIDPatch(scraperTargetID, scraperTargetRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ScraperTargetsApi - factory interface
 * @export
 */
export const ScraperTargetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get all scraper targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersGet(options?: any) {
            return ScraperTargetsApiFp(configuration).scrapersGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersPost(scraperTargetRequest: ScraperTargetRequest, options?: any) {
            return ScraperTargetsApiFp(configuration).scrapersPost(scraperTargetRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDDelete(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).scrapersScraperTargetIDDelete(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrapersScraperTargetIDPatch(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).scrapersScraperTargetIDPatch(scraperTargetID, scraperTargetRequest, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * ScraperTargetsApi - object-oriented interface
 * @export
 * @class ScraperTargetsApi
 * @extends {BaseAPI}
 */
export class ScraperTargetsApi extends BaseAPI {
    /**
     * 
     * @summary get all scraper targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public scrapersGet(options?: any) {
        return ScraperTargetsApiFp(this.configuration).scrapersGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary create a scraper target
     * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public scrapersPost(scraperTargetRequest: ScraperTargetRequest, options?: any) {
        return ScraperTargetsApiFp(this.configuration).scrapersPost(scraperTargetRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a scraper target
     * @param {string} scraperTargetID id of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public scrapersScraperTargetIDDelete(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).scrapersScraperTargetIDDelete(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update a scraper target
     * @param {string} scraperTargetID id of the scraper target
     * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public scrapersScraperTargetIDPatch(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).scrapersScraperTargetIDPatch(scraperTargetID, scraperTargetRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * SetupApi - axios parameter creator
 * @export
 */
export const SetupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options: any = {}): RequestArgs {
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options: any = {}): RequestArgs {
            // verify required parameter 'onboardingRequest' is not null or undefined
            if (onboardingRequest === null || onboardingRequest === undefined) {
                throw new RequiredError('onboardingRequest','Required parameter onboardingRequest was null or undefined when calling setupPost.');
            }
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OnboardingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(onboardingRequest || {}) : (onboardingRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsOnboarding> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).setupGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingResponse> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).setupPost(onboardingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options?: any) {
            return SetupApiFp(configuration).setupGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options?: any) {
            return SetupApiFp(configuration).setupPost(onboardingRequest, options)(axios, basePath);
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * 
     * @summary check if database has default user, org, bucket created, returns true if not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupGet(options?: any) {
        return SetupApiFp(this.configuration).setupGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary post onboarding request, to setup initial user, org and bucket
     * @param {OnboardingRequest} onboardingRequest source to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupPost(onboardingRequest: OnboardingRequest, options?: any) {
        return SetupApiFp(this.configuration).setupPost(onboardingRequest, options)(this.axios, this.basePath);
    }

}

/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesGet.');
            }
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesPost.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling sourcesPost.');
            }
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDDelete(sourceID: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDDelete.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDGet.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDHealthGet.');
            }
            const localVarPath = `/sources/{sourceID}/health`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDPatch.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling sourcesSourceIDPatch.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sources> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesPost(org, source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDBucketsGet(sourceID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDDelete(sourceID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDDelete(sourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDGet(sourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDHealthGet(sourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDPatch(sourceID, source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options?: any) {
            return SourcesApiFp(configuration).sourcesGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options?: any) {
            return SourcesApiFp(configuration).sourcesPost(org, source, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDDelete(sourceID: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDDelete(sourceID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDGet(sourceID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDHealthGet(sourceID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDPatch(sourceID, source, options)(axios, basePath);
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get all sources
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesGet(org: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a Source
     * @param {string} org specifies the organization of the resource
     * @param {Source} source source to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesPost(org: string, source: Source, options?: any) {
        return SourcesApiFp(this.configuration).sourcesPost(org, source, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a source
     * @param {string} sourceID ID of the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDDelete(sourceID: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDDelete(sourceID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a source
     * @param {string} sourceID ID of the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDGet(sourceID: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDGet(sourceID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources health
     * @param {string} sourceID ID of the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDHealthGet(sourceID: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDHealthGet(sourceID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Updates a Source
     * @param {string} sourceID ID of the source
     * @param {Source} source source update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDPatch(sourceID: string, source: Source, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDPatch(sourceID, source, options)(this.axios, this.basePath);
    }

}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'taskCreateRequest' is not null or undefined
            if (taskCreateRequest === null || taskCreateRequest === undefined) {
                throw new RequiredError('taskCreateRequest','Required parameter taskCreateRequest was null or undefined when calling tasksPost.');
            }
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskCreateRequest || {}) : (taskCreateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDGet.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsGet(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDLabelsGet.');
            }
            const localVarPath = `/tasks/{taskID}/labels`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a task config
         * @param {string} taskID ID of the task config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsLabelIDDelete(taskID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling tasksTaskIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}/labels/{labelID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsPost(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling tasksTaskIDLabelsPost.');
            }
            const localVarPath = `/tasks/{taskID}/labels`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDLogsGet.');
            }
            const localVarPath = `/tasks/{taskID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersGet.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDMembersPost.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersGet.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            const localVarPath = `/tasks/taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {Task} task task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, task: Task, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDPatch.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling tasksTaskIDPatch.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Task" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['afterTime'] = (afterTime as any).toISOString();
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['beforeTime'] = (beforeTime as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDGet.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDLogsGet.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDLogsGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDRetryPost.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDRetryPost.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/retry`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksGet(after, user, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksPost(taskCreateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDDelete(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsGet(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDLabelsGet(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a task config
         * @param {string} taskID ID of the task config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsLabelIDDelete(taskID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDLabelsLabelIDDelete(taskID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsPost(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDLabelsPost(taskID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDLogsGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {Task} task task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, task: Task, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDPatch(taskID, task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options?: any) {
            return TasksApiFp(configuration).tasksGet(after, user, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options?: any) {
            return TasksApiFp(configuration).tasksPost(taskCreateRequest, options)(axios, basePath);
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDDelete(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsGet(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDLabelsGet(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a task config
         * @param {string} taskID ID of the task config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsLabelIDDelete(taskID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDLabelsLabelIDDelete(taskID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLabelsPost(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDLabelsPost(taskID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDLogsGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {Task} task task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, task: Task, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDPatch(taskID, task, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options)(axios, basePath);
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Lists tasks, limit 100
     * @summary List tasks.
     * @param {string} [after] returns tasks after specified ID
     * @param {string} [user] filter tasks to a specific user name
     * @param {string} [org] filter tasks to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGet(after?: string, user?: string, org?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGet(after, user, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a new task
     * @param {TaskCreateRequest} taskCreateRequest task to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPost(taskCreateRequest: TaskCreateRequest, options?: any) {
        return TasksApiFp(this.configuration).tasksPost(taskCreateRequest, options)(this.axios, this.basePath);
    }

    /**
     * Deletes a task and all associated records
     * @summary Delete a task
     * @param {string} taskID ID of task to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDDelete(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDDelete(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an task
     * @param {string} taskID ID of task to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a task
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDLabelsGet(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDLabelsGet(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a task config
     * @param {string} taskID ID of the task config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDLabelsLabelIDDelete(taskID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDLabelsLabelIDDelete(taskID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a task
     * @param {string} taskID ID of the task
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDLabelsPost(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDLabelsPost(taskID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a task
     * @param {string} taskID ID of task to get logs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDLogsGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDLogsGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * Update a task. This will cancel all queued runs.
     * @summary Update a task
     * @param {string} taskID ID of task to get
     * @param {Task} task task update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDPatch(taskID: string, task: Task, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDPatch(taskID, task, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve list of run records for a task
     * @param {string} taskID ID of task to get runs for
     * @param {string} [after] returns runs after specified ID
     * @param {number} [limit] the number of runs to return
     * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
     * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a single run record for a task
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a run
     * @param {string} taskID ID of task to get logs for.
     * @param {string} runID ID of run to get logs for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retry a task run
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options)(this.axios, this.basePath);
    }

}

/**
 * TelegrafsApi - axios parameter creator
 * @export
 */
export const TelegrafsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgID specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling telegrafsGet.');
            }
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(telegrafRequest: TelegrafRequest, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling telegrafsPost.');
            }
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDDelete(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsGet(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDLabelsGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling telegrafsTelegrafIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels/{labelID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsPost(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling telegrafsTelegrafIDLabelsPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDPut.');
            }
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling telegrafsTelegrafIDPut.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegrafsApi - functional programming interface
 * @export
 */
export const TelegrafsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgID specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegrafs> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(telegrafRequest: TelegrafRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsPost(telegrafRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDDelete(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDDelete(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsGet(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDLabelsGet(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsPost(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDLabelsPost(telegrafID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TelegrafsApi - factory interface
 * @export
 */
export const TelegrafsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} orgID specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(orgID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(telegrafRequest: TelegrafRequest, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsPost(telegrafRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDDelete(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDDelete(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsGet(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDLabelsGet(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDLabelsPost(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDLabelsPost(telegrafID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options)(axios, basePath);
        },
    };
};

/**
 * TelegrafsApi - object-oriented interface
 * @export
 * @class TelegrafsApi
 * @extends {BaseAPI}
 */
export class TelegrafsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgID specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsGet(orgID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a telegraf config
     * @param {TelegrafRequest} telegrafRequest telegraf config to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsPost(telegrafRequest: TelegrafRequest, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsPost(telegrafRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDDelete(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDDelete(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDLabelsGet(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDLabelsGet(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDLabelsLabelIDDelete(telegrafID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDLabelsPost(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDLabelsPost(telegrafID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options)(this.axios, this.basePath);
    }

}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options: any = {}): RequestArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options: any = {}): RequestArgs {
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling mePasswordPut.');
            }
            const localVarPath = `/me/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersGet.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDMembersPost.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersGet.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersGet.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDMembersPost.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersGet.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            const localVarPath = `/tasks/taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options: any = {}): RequestArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling usersPost.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDDelete.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDGet.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDPasswordPut.');
            }
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling usersUserIDPasswordPut.');
            }
            const localVarPath = `/users/{userID}/password`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDPatch.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling usersUserIDPatch.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersGet.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDMembersPost.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersGet.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDOwnersPost.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).meGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).mePasswordPut(passwordResetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersPost(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDDelete(userID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDGet(userID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDPasswordPut(userID, passwordResetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDPatch(userID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: any) {
            return UsersApiFp(configuration).meGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options?: any) {
            return UsersApiFp(configuration).mePasswordPut(passwordResetBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any) {
            return UsersApiFp(configuration).usersGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options?: any) {
            return UsersApiFp(configuration).usersPost(user, options)(axios, basePath);
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options?: any) {
            return UsersApiFp(configuration).usersUserIDDelete(userID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options?: any) {
            return UsersApiFp(configuration).usersUserIDGet(userID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any) {
            return UsersApiFp(configuration).usersUserIDPasswordPut(userID, passwordResetBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options?: any) {
            return UsersApiFp(configuration).usersUserIDPatch(userID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersGet(bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public meGet(options?: any) {
        return UsersApiFp(this.configuration).meGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public mePasswordPut(passwordResetBody: PasswordResetBody, options?: any) {
        return UsersApiFp(this.configuration).mePasswordPut(passwordResetBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersGet(orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersGet(orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersGet(taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersGet(taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(options?: any) {
        return UsersApiFp(this.configuration).usersGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(user: User, options?: any) {
        return UsersApiFp(this.configuration).usersPost(user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary deletes a user
     * @param {string} userID ID of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDDelete(userID: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDDelete(userID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a user
     * @param {string} userID ID of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDGet(userID: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDGet(userID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {string} userID ID of the user
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDPasswordPut(userID, passwordResetBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a user
     * @param {string} userID ID of user to update
     * @param {User} user user update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDPatch(userID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDPatch(userID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view members
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersGet(viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view member
     * @param {string} viewID ID of the view
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an view
     * @param {string} userID ID of member to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view owners
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersGet(viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view owner
     * @param {string} viewID ID of the view
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a view
     * @param {string} userID ID of owner to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

}

/**
 * ViewsApi - axios parameter creator
 * @export
 */
export const ViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling dashboardsDashboardIDCellsCellIDViewPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling viewsGet.');
            }
            const localVarPath = `/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling viewsPost.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling viewsPost.');
            }
            const localVarPath = `/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDDelete.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDGet.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a view
         * @param {string} viewID ID of the view
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsGet(viewID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDLabelsGet.');
            }
            const localVarPath = `/views/{viewID}/labels`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a view config
         * @param {string} viewID ID of the view config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsLabelIDDelete(viewID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDLabelsLabelIDDelete.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling viewsViewIDLabelsLabelIDDelete.');
            }
            const localVarPath = `/views/{viewID}/labels/{labelID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a view
         * @param {string} viewID ID of the view
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsPost(viewID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDLabelsPost.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling viewsViewIDLabelsPost.');
            }
            const localVarPath = `/views/{viewID}/labels`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersGet.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDMembersPost.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersGet.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDOwnersPost.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDPatch.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling viewsViewIDPatch.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Views> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsPost(org, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDDelete(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a view
         * @param {string} viewID ID of the view
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsGet(viewID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDLabelsGet(viewID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a view config
         * @param {string} viewID ID of the view config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsLabelIDDelete(viewID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDLabelsLabelIDDelete(viewID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a view
         * @param {string} viewID ID of the view
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsPost(viewID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDLabelsPost(viewID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDPatch(viewID, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
            return ViewsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
            return ViewsApiFp(configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options?: any) {
            return ViewsApiFp(configuration).viewsGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options?: any) {
            return ViewsApiFp(configuration).viewsPost(org, view, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDDelete(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a view
         * @param {string} viewID ID of the view
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsGet(viewID: string, zapTraceSpan?: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDLabelsGet(viewID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a view config
         * @param {string} viewID ID of the view config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsLabelIDDelete(viewID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDLabelsLabelIDDelete(viewID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a view
         * @param {string} viewID ID of the view
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDLabelsPost(viewID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDLabelsPost(viewID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDPatch(viewID, view, options)(axios, basePath);
        },
    };
};

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public dashboardsDashboardIDCellsCellIDViewGet(dashboardID: string, cellID: string, options?: any) {
        return ViewsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewGet(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public dashboardsDashboardIDCellsCellIDViewPatch(dashboardID: string, cellID: string, view: View, options?: any) {
        return ViewsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDViewPatch(dashboardID, cellID, view, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all views
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsGet(org: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary A view contains information about the visual representation of data
     * @param {string} org specifies the organization of the resource
     * @param {View} view view to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsPost(org: string, view: View, options?: any) {
        return ViewsApiFp(this.configuration).viewsPost(org, view, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a view
     * @param {string} viewID ID of view to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDDelete(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDDelete(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a single View
     * @param {string} viewID ID of view to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a view
     * @param {string} viewID ID of the view
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDLabelsGet(viewID: string, zapTraceSpan?: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDLabelsGet(viewID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a view config
     * @param {string} viewID ID of the view config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDLabelsLabelIDDelete(viewID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDLabelsLabelIDDelete(viewID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a view
     * @param {string} viewID ID of the view
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDLabelsPost(viewID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDLabelsPost(viewID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view members
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view member
     * @param {string} viewID ID of the view
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an view
     * @param {string} userID ID of member to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view owners
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view owner
     * @param {string} viewID ID of the view
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a view
     * @param {string} userID ID of owner to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single view
     * @param {string} viewID ID of view to update
     * @param {View} view patching of a view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDPatch(viewID: string, view: View, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDPatch(viewID, view, options)(this.axios, this.basePath);
    }

}

/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, body: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling writePost.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling writePost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling writePost.');
            }
            const localVarPath = `/write`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }

            if (contentEncoding !== undefined && contentEncoding !== null) {
                localVarHeaderParameter['Content-Encoding'] = String(contentEncoding);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (contentLength !== undefined && contentLength !== null) {
                localVarHeaderParameter['Content-Length'] = String(contentLength);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, body: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WriteApiAxiosParamCreator(configuration).writePost(org, bucket, body, contentEncoding, contentType, contentLength, accept, precision, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, body: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any) {
            return WriteApiFp(configuration).writePost(org, bucket, body, contentEncoding, contentType, contentLength, accept, precision, options)(axios, basePath);
        },
    };
};

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI {
    /**
     * 
     * @summary write time-series data into influxdb
     * @param {string} org specifies the destination organization for writes
     * @param {string} bucket specifies the destination bucket for writes
     * @param {string} body line protocol body
     * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
     * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
     * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
     * @param {'application/json'} [accept] specifies the return content format.
     * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public writePost(org: string, bucket: string, body: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any) {
        return WriteApiFp(this.configuration).writePost(org, bucket, body, contentEncoding, contentType, contentLength, accept, precision, options)(this.axios, this.basePath);
    }

}

