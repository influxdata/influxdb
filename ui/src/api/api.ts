// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Influx API Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost:9999/api/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    id?: string;
    /**
     * 
     * @type {AuthorizationLinks}
     * @memberof Authorization
     */
    links?: AuthorizationLinks;
    /**
     * 
     * @type {Owners}
     * @memberof Authorization
     */
    owner: Owners;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof Authorization
     */
    permissions?: Array<Permission>;
    /**
     * if inactive the token is inactive and requests using the token will be rejected.
     * @type {string}
     * @memberof Authorization
     */
    status?: Authorization.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    token?: string;
}

/**
 * @export
 * @namespace Authorization
 */
export namespace Authorization {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface AuthorizationLinks
 */
export interface AuthorizationLinks {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationLinks
     */
    user?: string;
}

/**
 * 
 * @export
 * @interface Authorizations
 */
export interface Authorizations {
    /**
     * 
     * @type {Array<Authorization>}
     * @memberof Authorizations
     */
    auths?: Array<Authorization>;
    /**
     * 
     * @type {Links}
     * @memberof Authorizations
     */
    links?: Links;
}

/**
 * A description of a particular axis for a visualization
 * @export
 * @interface Axis
 */
export interface Axis {
    /**
     * Base represents the radix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    base?: string;
    /**
     * The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits
     * @type {Array<number>}
     * @memberof Axis
     */
    bounds?: Array<number>;
    /**
     * label is a description of this Axis
     * @type {string}
     * @memberof Axis
     */
    label?: string;
    /**
     * Prefix represents a label prefix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    prefix?: string;
    /**
     * Scale is the axis formatting scale. Supported: \"log\", \"linear\"
     * @type {string}
     * @memberof Axis
     */
    scale?: string;
    /**
     * Suffix represents a label suffix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    suffix?: string;
}

/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    id?: string;
    /**
     * 
     * @type {BucketLinks}
     * @memberof Bucket
     */
    links?: BucketLinks;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    name: string;
    /**
     * 
     * @type {Owners}
     * @memberof Bucket
     */
    owners?: Owners;
    /**
     * rules to expire or retain data.  No rules means data never expires.
     * @type {Array<BucketRetentionRules>}
     * @memberof Bucket
     */
    retentionRules: Array<BucketRetentionRules>;
}

/**
 * 
 * @export
 * @interface BucketLinks
 */
export interface BucketLinks {
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    org?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketLinks
     */
    write?: string;
}

/**
 * 
 * @export
 * @interface BucketRetentionRules
 */
export interface BucketRetentionRules {
    /**
     * duration in seconds for how long data will be kept in the database.
     * @type {number}
     * @memberof BucketRetentionRules
     */
    everySeconds: number;
    /**
     * 
     * @type {string}
     * @memberof BucketRetentionRules
     */
    type: BucketRetentionRules.TypeEnum;
}

/**
 * @export
 * @namespace BucketRetentionRules
 */
export namespace BucketRetentionRules {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Expire = 'expire'
    }
}

/**
 * 
 * @export
 * @interface Buckets
 */
export interface Buckets {
    /**
     * 
     * @type {Array<Bucket>}
     * @memberof Buckets
     */
    buckets?: Array<Bucket>;
    /**
     * 
     * @type {Links}
     * @memberof Buckets
     */
    links?: Links;
}

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    h?: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    id?: string;
    /**
     * 
     * @type {CellLinks}
     * @memberof Cell
     */
    links?: CellLinks;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name?: string;
    /**
     * The reference to a view from the views API
     * @type {string}
     * @memberof Cell
     */
    viewID?: string;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    y?: number;
}

/**
 * 
 * @export
 * @interface CellLinks
 */
export interface CellLinks {
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    view?: string;
}

/**
 * 
 * @export
 * @interface CellUpdate
 */
export interface CellUpdate {
    /**
     * 
     * @type {string}
     * @memberof CellUpdate
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Cells
 */
export interface Cells extends Array<Cell> {
}

/**
 * 
 * @export
 * @interface ConstantMacroProperties
 */
export interface ConstantMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof ConstantMacroProperties
     */
    type?: ConstantMacroProperties.TypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConstantMacroProperties
     */
    values?: Array<string>;
}

/**
 * @export
 * @namespace ConstantMacroProperties
 */
export namespace ConstantMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Constant = 'constant'
    }
}

/**
 * 
 * @export
 * @interface CreateCell
 */
export interface CreateCell {
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    h?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCell
     */
    name?: string;
    /**
     * makes a copy of the provided view
     * @type {string}
     * @memberof CreateCell
     */
    usingView?: string;
    /**
     * uses the view provided in the request
     * @type {string}
     * @memberof CreateCell
     */
    viewID?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    y?: number;
}

/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * 
     * @type {Cells}
     * @memberof Dashboard
     */
    cells?: Cells;
    /**
     * user-facing description of the dashboard
     * @type {string}
     * @memberof Dashboard
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    id?: string;
    /**
     * 
     * @type {DashboardLinks}
     * @memberof Dashboard
     */
    links?: DashboardLinks;
    /**
     * 
     * @type {DashboardMeta}
     * @memberof Dashboard
     */
    meta?: DashboardMeta;
    /**
     * user-facing name of the dashboard
     * @type {string}
     * @memberof Dashboard
     */
    name?: string;
}

/**
 * Color defines an encoding of data value into color space
 * @export
 * @interface DashboardColor
 */
export interface DashboardColor {
    /**
     * Hex is the hex number of the color
     * @type {string}
     * @memberof DashboardColor
     */
    hex?: string;
    /**
     * ID is the unique id of the view color
     * @type {string}
     * @memberof DashboardColor
     */
    id?: string;
    /**
     * Name is the user-facing name of the hex color
     * @type {string}
     * @memberof DashboardColor
     */
    name?: string;
    /**
     * Type is how the color is used.
     * @type {string}
     * @memberof DashboardColor
     */
    type?: DashboardColor.TypeEnum;
    /**
     * Value is the data value mapped to this color
     * @type {number}
     * @memberof DashboardColor
     */
    value?: number;
}

/**
 * @export
 * @namespace DashboardColor
 */
export namespace DashboardColor {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Min = 'min',
        Max = 'max',
        Threshold = 'threshold'
    }
}

/**
 * 
 * @export
 * @interface DashboardLinks
 */
export interface DashboardLinks {
    /**
     * 
     * @type {string}
     * @memberof DashboardLinks
     */
    cells?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface DashboardMeta
 */
export interface DashboardMeta {
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    updatedAt?: string;
}

/**
 * 
 * @export
 * @interface DashboardQuery
 */
export interface DashboardQuery {
    /**
     * Optional Y-axis user-facing label
     * @type {string}
     * @memberof DashboardQuery
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardQuery
     */
    query: string;
    /**
     * 
     * @type {QueryConfig}
     * @memberof DashboardQuery
     */
    queryConfig?: QueryConfig;
    /**
     * 
     * @type {DashboardQueryRange}
     * @memberof DashboardQuery
     */
    range?: DashboardQueryRange;
    /**
     * Optional URI for data source for this query
     * @type {string}
     * @memberof DashboardQuery
     */
    source?: string;
}

/**
 * Optional default range of the Y-axis
 * @export
 * @interface DashboardQueryRange
 */
export interface DashboardQueryRange {
    /**
     * Lower bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    lower: number;
    /**
     * Upper bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    upper: number;
}

/**
 * 
 * @export
 * @interface Dashboards
 */
export interface Dashboards {
    /**
     * 
     * @type {Array<Dashboard>}
     * @memberof Dashboards
     */
    dashboards?: Array<Dashboard>;
    /**
     * 
     * @type {Links}
     * @memberof Dashboards
     */
    links?: Links;
}

/**
 * dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 * @export
 * @interface Dialect
 */
export interface Dialect {
    /**
     * https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns
     * @type {Array<string>}
     * @memberof Dialect
     */
    annotations?: Array<Dialect.AnnotationsEnum>;
    /**
     * character prefixed to comment strings
     * @type {string}
     * @memberof Dialect
     */
    commentPrefix?: string;
    /**
     * format of timestamps
     * @type {string}
     * @memberof Dialect
     */
    dateTimeFormat?: Dialect.DateTimeFormatEnum;
    /**
     * separator between cells; the default is ,
     * @type {string}
     * @memberof Dialect
     */
    delimiter?: string;
    /**
     * if true, the results will contain a header row
     * @type {boolean}
     * @memberof Dialect
     */
    header?: boolean;
}

/**
 * @export
 * @namespace Dialect
 */
export namespace Dialect {
    /**
     * @export
     * @enum {string}
     */
    export enum AnnotationsEnum {
        Group = 'group',
        Datatype = 'datatype',
        Default = 'default'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DateTimeFormatEnum {
        RFC3339 = 'RFC3339',
        RFC3339Nano = 'RFC3339Nano'
    }
}

/**
 * 
 * @export
 * @interface EmptyViewProperties
 */
export interface EmptyViewProperties {
    /**
     * 
     * @type {string}
     * @memberof EmptyViewProperties
     */
    type?: EmptyViewProperties.TypeEnum;
}

/**
 * @export
 * @namespace EmptyViewProperties
 */
export namespace EmptyViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Empty = 'empty'
    }
}

/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * Alias overrides the field name in the returned response.  Applies only if type is `func`
     * @type {string}
     * @memberof Field
     */
    alias?: string;
    /**
     * Args are the arguments to the function
     * @type {Array<Field>}
     * @memberof Field
     */
    args?: Array<Field>;
    /**
     * type describes the field type. func is a function; field is a field reference
     * @type {string}
     * @memberof Field
     */
    type?: Field.TypeEnum;
    /**
     * value is the value of the field.  Meaning of the value is implied by the `type` key
     * @type {string}
     * @memberof Field
     */
    value?: string;
}

/**
 * @export
 * @namespace Field
 */
export namespace Field {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Func = 'func',
        Field = 'field',
        Integer = 'integer',
        Number = 'number',
        Regex = 'regex',
        Wildcard = 'wildcard'
    }
}

/**
 * 
 * @export
 * @interface FluxLinks
 */
export interface FluxLinks {
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    ast?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxLinks
     */
    suggestions?: string;
}

/**
 * 
 * @export
 * @interface FluxSuggestions
 */
export interface FluxSuggestions {
    /**
     * 
     * @type {FluxSuggestionsFuncs}
     * @memberof FluxSuggestions
     */
    funcs?: FluxSuggestionsFuncs;
}

/**
 * 
 * @export
 * @interface FluxSuggestionsFuncs
 */
export interface FluxSuggestionsFuncs {
    /**
     * 
     * @type {string}
     * @memberof FluxSuggestionsFuncs
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof FluxSuggestionsFuncs
     */
    params?: any;
}

/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {Array<Health>}
     * @memberof Health
     */
    checks?: Array<Health>;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    status?: Health.StatusEnum;
}

/**
 * @export
 * @namespace Health
 */
export namespace Health {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Unhealthy = 'unhealthy',
        Healthy = 'healthy'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse200
     */
    links?: Links;
    /**
     * 
     * @type {Array<Task>}
     * @memberof InlineResponse200
     */
    tasks?: Array<Task>;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2001
     */
    links?: Links;
    /**
     * 
     * @type {Array<Run>}
     * @memberof InlineResponse2001
     */
    runs?: Array<Run>;
}

/**
 * 
 * @export
 * @interface IsOnboarding
 */
export interface IsOnboarding {
    /**
     * 
     * @type {boolean}
     * @memberof IsOnboarding
     */
    allowed?: boolean;
}

/**
 * flux query to be analyzed.
 * @export
 * @interface LanguageRequest
 */
export interface LanguageRequest {
    /**
     * flux query script to be analyzed
     * @type {string}
     * @memberof LanguageRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface LineProtocolError
 */
export interface LineProtocolError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolError
     */
    code: LineProtocolError.CodeEnum;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    err: string;
    /**
     * first line within sent body containing malformed data
     * @type {number}
     * @memberof LineProtocolError
     */
    line?: number;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    op: string;
}

/**
 * @export
 * @namespace LineProtocolError
 */
export namespace LineProtocolError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        EmptyValue = 'empty value'
    }
}

/**
 * 
 * @export
 * @interface LineProtocolLengthError
 */
export interface LineProtocolLengthError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    code: LineProtocolLengthError.CodeEnum;
    /**
     * max length in bytes for a body of line-protocol.
     * @type {number}
     * @memberof LineProtocolLengthError
     */
    maxLength: number;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    message: string;
}

/**
 * @export
 * @namespace LineProtocolLengthError
 */
export namespace LineProtocolLengthError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        Invalid = 'invalid'
    }
}

/**
 * URI of resource.
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href: string;
}

/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    next?: Link;
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    prev?: Link;
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    self: Link;
}

/**
 * 
 * @export
 * @interface LogEvent
 */
export interface LogEvent {
    /**
     * A description of the event that occurred.
     * @type {string}
     * @memberof LogEvent
     */
    message?: string;
    /**
     * Time event occurred, RFC3339Nano.
     * @type {Date}
     * @memberof LogEvent
     */
    time?: Date;
}

/**
 * Contains the configuration for the log viewer
 * @export
 * @interface LogViewProperties
 */
export interface LogViewProperties {
    /**
     * Defines the order, names, and visibility of columns in the log viewer table
     * @type {Array<LogViewerColumn>}
     * @memberof LogViewProperties
     */
    columns: Array<LogViewerColumn>;
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    shape: LogViewProperties.ShapeEnum;
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    type: LogViewProperties.TypeEnum;
}

/**
 * @export
 * @namespace LogViewProperties
 */
export namespace LogViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum ShapeEnum {
        ChronografV2 = 'chronograf-v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LogViewer = 'log-viewer'
    }
}

/**
 * Contains a specific column's settings.
 * @export
 * @interface LogViewerColumn
 */
export interface LogViewerColumn {
    /**
     * Unique identifier name of the column
     * @type {string}
     * @memberof LogViewerColumn
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof LogViewerColumn
     */
    position: number;
    /**
     * Composable settings options for the column
     * @type {Array<LogViewerColumnSettings>}
     * @memberof LogViewerColumn
     */
    settings: Array<LogViewerColumnSettings>;
}

/**
 * Type and value and optional name of a setting.
 * @export
 * @interface LogViewerColumnSettings
 */
export interface LogViewerColumnSettings {
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    value: string;
}

/**
 * 
 * @export
 * @interface Logs
 */
export interface Logs {
    /**
     * 
     * @type {Array<LogEvent>}
     * @memberof Logs
     */
    events?: Array<LogEvent>;
}

/**
 * 
 * @export
 * @interface Macro
 */
export interface Macro {
    /**
     * 
     * @type {any}
     * @memberof Macro
     */
    arguments?: any;
    /**
     * 
     * @type {string}
     * @memberof Macro
     */
    id?: string;
    /**
     * 
     * @type {MacroLinks}
     * @memberof Macro
     */
    links?: MacroLinks;
    /**
     * 
     * @type {string}
     * @memberof Macro
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Macro
     */
    selected?: Array<string>;
}

/**
 * 
 * @export
 * @interface MacroLinks
 */
export interface MacroLinks {
    /**
     * 
     * @type {string}
     * @memberof MacroLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface Macros
 */
export interface Macros {
    /**
     * 
     * @type {Macro}
     * @memberof Macros
     */
    macros?: Macro;
}

/**
 * 
 * @export
 * @interface MapMacroProperties
 */
export interface MapMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof MapMacroProperties
     */
    type?: MapMacroProperties.TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof MapMacroProperties
     */
    values?: any;
}

/**
 * @export
 * @namespace MapMacroProperties
 */
export namespace MapMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Map = 'map'
    }
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof ModelError
     */
    code: ModelError.CodeEnum;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    err: string;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    op: string;
}

/**
 * @export
 * @namespace ModelError
 */
export namespace ModelError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        EmptyValue = 'empty value'
    }
}

/**
 * 
 * @export
 * @interface OnboardingRequest
 */
export interface OnboardingRequest {
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    org: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    password: string;
    /**
     * 
     * @type {number}
     * @memberof OnboardingRequest
     */
    retentionPeriodHrs?: number;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    username: string;
}

/**
 * 
 * @export
 * @interface OnboardingResponse
 */
export interface OnboardingResponse {
    /**
     * 
     * @type {Authorization}
     * @memberof OnboardingResponse
     */
    auth?: Authorization;
    /**
     * 
     * @type {Bucket}
     * @memberof OnboardingResponse
     */
    bucket?: Bucket;
    /**
     * 
     * @type {Organization}
     * @memberof OnboardingResponse
     */
    org?: Organization;
    /**
     * 
     * @type {User}
     * @memberof OnboardingResponse
     */
    user?: User;
}

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * 
     * @type {OrganizationLinks}
     * @memberof Organization
     */
    links?: OrganizationLinks;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * 
     * @type {Owners}
     * @memberof Organization
     */
    owners?: Owners;
    /**
     * if inactive the organization is inactive.
     * @type {string}
     * @memberof Organization
     */
    status?: Organization.StatusEnum;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface OrganizationLinks
 */
export interface OrganizationLinks {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    buckets?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    dashboards?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    tasks?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLinks
     */
    users?: string;
}

/**
 * 
 * @export
 * @interface Organizations
 */
export interface Organizations {
    /**
     * 
     * @type {Links}
     * @memberof Organizations
     */
    links?: Links;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof Organizations
     */
    orgs?: Array<Organization>;
}

/**
 * 
 * @export
 * @interface Owners
 */
export interface Owners {
    /**
     * 
     * @type {Organizations}
     * @memberof Owners
     */
    organizations?: Organizations;
    /**
     * 
     * @type {Users}
     * @memberof Owners
     */
    users?: Users;
}

/**
 * 
 * @export
 * @interface PasswordResetBody
 */
export interface PasswordResetBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetBody
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    action?: Permission.ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    resource?: Permission.ResourceEnum;
}

/**
 * @export
 * @namespace Permission
 */
export namespace Permission {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Read = 'read',
        Write = 'write',
        Create = 'create',
        Delete = 'delete'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResourceEnum {
        User = 'user',
        Org = 'org',
        Taskid = 'task/:id',
        Bucketid = 'bucket/:id',
        Dashboardid = 'dashboard/:id',
        Orgid = 'org/:id',
        Orgidtask = 'org/:id/task',
        Orgidbucket = 'org/:id/bucket',
        Orgidsource = 'org/:id/source',
        Orgiddashboard = 'org/:id/dashboard'
    }
}

/**
 * flux query or specification to be planned. The spec and query fields are mutually exclusive.
 * @export
 * @interface PlanRequest
 */
export interface PlanRequest {
    /**
     * flux query script to be analyzed
     * @type {string}
     * @memberof PlanRequest
     */
    query?: string;
    /**
     * 
     * @type {QuerySpecification}
     * @memberof PlanRequest
     */
    spec?: QuerySpecification;
}

/**
 * flux query or specification to be planned.
 * @export
 * @interface PlanResponse
 */
export interface PlanResponse {
    /**
     * logical plan of the query.
     * @type {any}
     * @memberof PlanResponse
     */
    logical?: any;
    /**
     * physical plan of the query.
     * @type {any}
     * @memberof PlanResponse
     */
    physical?: any;
    /**
     * 
     * @type {QuerySpecification}
     * @memberof PlanResponse
     */
    spec?: QuerySpecification;
}

/**
 * query influx with specified return formatting. The spec and query fields are mutually exclusive.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    cluster?: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    db?: string;
    /**
     * 
     * @type {Dialect}
     * @memberof Query
     */
    dialect?: Dialect;
    /**
     * query script to execute.
     * @type {string}
     * @memberof Query
     */
    query: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    rp?: string;
    /**
     * 
     * @type {QuerySpecification}
     * @memberof Query
     */
    spec?: QuerySpecification;
    /**
     * type of query
     * @type {string}
     * @memberof Query
     */
    type?: Query.TypeEnum;
}

/**
 * @export
 * @namespace Query
 */
export namespace Query {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Flux = 'flux',
        Influxql = 'influxql'
    }
}

/**
 * 
 * @export
 * @interface QueryConfig
 */
export interface QueryConfig {
    /**
     * 
     * @type {boolean}
     * @memberof QueryConfig
     */
    areTagsAccepted: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    database: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof QueryConfig
     */
    fields: Array<Field>;
    /**
     * 
     * @type {QueryConfigGroupBy}
     * @memberof QueryConfig
     */
    groupBy: QueryConfigGroupBy;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    measurement: string;
    /**
     * 
     * @type {QueryConfigRange}
     * @memberof QueryConfig
     */
    range?: QueryConfigRange;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    rawText?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    retentionPolicy: string;
    /**
     * 
     * @type {any}
     * @memberof QueryConfig
     */
    tags: any;
}

/**
 * 
 * @export
 * @interface QueryConfigGroupBy
 */
export interface QueryConfigGroupBy {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryConfigGroupBy
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QueryConfigGroupBy
     */
    time: string;
}

/**
 * 
 * @export
 * @interface QueryConfigRange
 */
export interface QueryConfigRange {
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    lower: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    upper: string;
}

/**
 * 
 * @export
 * @interface QueryMacroProperties
 */
export interface QueryMacroProperties {
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    queryType?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryMacroProperties
     */
    type?: QueryMacroProperties.TypeEnum;
}

/**
 * @export
 * @namespace QueryMacroProperties
 */
export namespace QueryMacroProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Query = 'query'
    }
}

/**
 * consists of a set of operations and a set of edges between those operations to instruct the query engine to operate.
 * @export
 * @interface QuerySpecification
 */
export interface QuerySpecification {
    /**
     * 
     * @type {Dialect}
     * @memberof QuerySpecification
     */
    dialect?: Dialect;
    /**
     * list of declaring a parent child id relationship between operations
     * @type {Array<QuerySpecificationEdges>}
     * @memberof QuerySpecification
     */
    edges?: Array<QuerySpecificationEdges>;
    /**
     * 
     * @type {Array<QuerySpecificationOperations>}
     * @memberof QuerySpecification
     */
    operations?: Array<QuerySpecificationOperations>;
    /**
     * 
     * @type {QuerySpecificationResources}
     * @memberof QuerySpecification
     */
    resources?: QuerySpecificationResources;
}

/**
 * 
 * @export
 * @interface QuerySpecificationEdges
 */
export interface QuerySpecificationEdges {
    /**
     * id of child node of parent within the graph of operations
     * @type {string}
     * @memberof QuerySpecificationEdges
     */
    child?: string;
    /**
     * id of parent node of child within graph of opertions
     * @type {string}
     * @memberof QuerySpecificationEdges
     */
    parent?: string;
}

/**
 * 
 * @export
 * @interface QuerySpecificationOperations
 */
export interface QuerySpecificationOperations {
    /**
     * identifier for this operation; it must be unique per query specification; used in edges
     * @type {string}
     * @memberof QuerySpecificationOperations
     */
    id?: string;
    /**
     * name of the operation to perform
     * @type {string}
     * @memberof QuerySpecificationOperations
     */
    kind?: string;
    /**
     * set of properties that specify details of the operation. These vary by the kind of operation.
     * @type {any}
     * @memberof QuerySpecificationOperations
     */
    spec?: any;
}

/**
 * optional set of contraints on the resources the query can consume
 * @export
 * @interface QuerySpecificationResources
 */
export interface QuerySpecificationResources {
    /**
     * number of concurrent workers allowed to process this query; 0 indicates the planner can pick the optimal concurrency.
     * @type {number}
     * @memberof QuerySpecificationResources
     */
    concurrencyQuota?: number;
    /**
     * number of bytes of RAM this query may consume; 0 means unlimited.
     * @type {number}
     * @memberof QuerySpecificationResources
     */
    memoryBytesQuota?: number;
    /**
     * priority of the query
     * @type {any}
     * @memberof QuerySpecificationResources
     */
    priority?: any;
}

/**
 * Describes a field that can be renamed and made visible or invisible
 * @export
 * @interface RenamableField
 */
export interface RenamableField {
    /**
     * This is the name that a field is renamed to by the user
     * @type {string}
     * @memberof RenamableField
     */
    displayName?: string;
    /**
     * This is the calculated name of a field
     * @type {string}
     * @memberof RenamableField
     */
    internalName?: string;
    /**
     * Indicates whether this field should be visible on the table
     * @type {boolean}
     * @memberof RenamableField
     */
    visible?: boolean;
}

/**
 * 
 * @export
 * @interface Routes
 */
export interface Routes {
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    auths?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    buckets?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    dashboards?: string;
    /**
     * 
     * @type {RoutesExternal}
     * @memberof Routes
     */
    external?: RoutesExternal;
    /**
     * 
     * @type {FluxLinks}
     * @memberof Routes
     */
    flux?: FluxLinks;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    orgs?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    sources?: string;
    /**
     * 
     * @type {RoutesSystem}
     * @memberof Routes
     */
    system?: RoutesSystem;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    tasks?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    users?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    write?: string;
}

/**
 * 
 * @export
 * @interface RoutesExternal
 */
export interface RoutesExternal {
    /**
     * 
     * @type {string}
     * @memberof RoutesExternal
     */
    statusFeed?: string;
}

/**
 * 
 * @export
 * @interface RoutesSystem
 */
export interface RoutesSystem {
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    debug?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    health?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    metrics?: string;
}

/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {Error}
     * @memberof Run
     */
    error?: Error;
    /**
     * Time run finished executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    finishedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    id?: string;
    /**
     * Link to the full logs for a run.
     * @type {string}
     * @memberof Run
     */
    log?: string;
    /**
     * Time run was manually requested, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    requestedAt?: Date;
    /**
     * Time used for run's \"now\" option, RFC3339.
     * @type {Date}
     * @memberof Run
     */
    scheduledFor?: Date;
    /**
     * Time run started executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    startedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    status?: Run.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    taskID?: string;
}

/**
 * @export
 * @namespace Run
 */
export namespace Run {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Scheduled = 'scheduled',
        Executing = 'executing',
        Failed = 'failed',
        Success = 'success'
    }
}

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {boolean}
     * @memberof Source
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    defaultRP?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Source
     */
    insecureSkipVerify?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Source
     */
    languages?: Array<Source.LanguagesEnum>;
    /**
     * 
     * @type {SourceLinks}
     * @memberof Source
     */
    links?: SourceLinks;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    metaUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    organizationID?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    sharedSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    telegraf?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    type?: Source.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    username?: string;
}

/**
 * @export
 * @namespace Source
 */
export namespace Source {
    /**
     * @export
     * @enum {string}
     */
    export enum LanguagesEnum {
        Flux = 'flux',
        Influxql = 'influxql',
        Spec = 'spec'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        V1 = 'v1',
        V2 = 'v2',
        Self = 'self'
    }
}

/**
 * 
 * @export
 * @interface SourceLinks
 */
export interface SourceLinks {
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface Sources
 */
export interface Sources {
    /**
     * 
     * @type {MacroLinks}
     * @memberof Sources
     */
    links?: MacroLinks;
    /**
     * 
     * @type {Array<Source>}
     * @memberof Sources
     */
    sources?: Array<Source>;
}

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * A task repetition schedule in the form '* * * * * *'; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    cron?: string;
    /**
     * How long to wait before running the task
     * @type {string}
     * @memberof Task
     */
    delay?: string;
    /**
     * A simple task repetition schedule; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    every?: string;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof Task
     */
    flux: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * 
     * @type {TaskLinks}
     * @memberof Task
     */
    links?: TaskLinks;
    /**
     * A description of the task.
     * @type {string}
     * @memberof Task
     */
    name: string;
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof Task
     */
    organizationId?: string;
    /**
     * 
     * @type {Owners}
     * @memberof Task
     */
    owners?: Owners;
    /**
     * The current status of the task. When updated to 'inactive', cancels all queued jobs of this task.
     * @type {string}
     * @memberof Task
     */
    status?: Task.StatusEnum;
}

/**
 * @export
 * @namespace Task
 */
export namespace Task {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskCreateRequest
 */
export interface TaskCreateRequest {
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    flux: string;
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    organizationId: string;
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskCreateRequest
     */
    status?: TaskCreateRequest.StatusEnum;
}

/**
 * @export
 * @namespace TaskCreateRequest
 */
export namespace TaskCreateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskLinks
 */
export interface TaskLinks {
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    logs?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    members?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    owners?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    runs?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface TaskUpdateRequest
 */
export interface TaskUpdateRequest {
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    flux?: string;
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    status?: TaskUpdateRequest.StatusEnum;
}

/**
 * @export
 * @namespace TaskUpdateRequest
 */
export namespace TaskUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface Telegraf
 */
export interface Telegraf extends TelegrafRequest {
    /**
     * 
     * @type {string}
     * @memberof Telegraf
     */
    id?: string;
    /**
     * 
     * @type {any}
     * @memberof Telegraf
     */
    links?: any;
    /**
     * 
     * @type {Owners}
     * @memberof Telegraf
     */
    owners?: Owners;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInput
 */
export interface TelegrafPluginInput {
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDocker
 */
export interface TelegrafPluginInputDocker {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    endpoint?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFile
 */
export interface TelegrafPluginInputFile {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputFile
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetes
 */
export interface TelegrafPluginInputKubernetes {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParser
 */
export interface TelegrafPluginInputLogParser {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputLogParser
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstat
 */
export interface TelegrafPluginInputProcstat {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    exe?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheus
 */
export interface TelegrafPluginInputPrometheus {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputPrometheus
     */
    urls?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedis
 */
export interface TelegrafPluginInputRedis {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    password?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputRedis
     */
    servers?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslog
 */
export interface TelegrafPluginInputSyslog {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    server?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFile
 */
export interface TelegrafPluginOutputFile {
    /**
     * 
     * @type {Array<TelegrafPluginOutputFileFiles>}
     * @memberof TelegrafPluginOutputFile
     */
    files: Array<TelegrafPluginOutputFileFiles>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileFiles
 */
export interface TelegrafPluginOutputFileFiles {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileFiles
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileFiles
     */
    type?: TelegrafPluginOutputFileFiles.TypeEnum;
}

/**
 * @export
 * @namespace TelegrafPluginOutputFileFiles
 */
export namespace TelegrafPluginOutputFileFiles {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Stdout = 'stdout',
        Path = 'path'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2
 */
export interface TelegrafPluginOutputInfluxDBV2 {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    organization: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    token: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    urls: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafRequest
 */
export interface TelegrafRequest {
    /**
     * 
     * @type {TelegrafRequestAgent}
     * @memberof TelegrafRequest
     */
    agent?: TelegrafRequestAgent;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    name?: string;
    /**
     * 
     * @type {Array<TelegrafRequestPlugins>}
     * @memberof TelegrafRequest
     */
    plugins?: Array<TelegrafRequestPlugins>;
}

/**
 * 
 * @export
 * @interface TelegrafRequestAgent
 */
export interface TelegrafRequestAgent {
    /**
     * 
     * @type {number}
     * @memberof TelegrafRequestAgent
     */
    interval?: number;
}

/**
 * 
 * @export
 * @interface TelegrafRequestPlugins
 */
export interface TelegrafRequestPlugins {
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequestPlugins
     */
    comment?: string;
    /**
     * 
     * @type {any}
     * @memberof TelegrafRequestPlugins
     */
    config?: any;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequestPlugins
     */
    name?: TelegrafRequestPlugins.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequestPlugins
     */
    type?: TelegrafRequestPlugins.TypeEnum;
}

/**
 * @export
 * @namespace TelegrafRequestPlugins
 */
export namespace TelegrafRequestPlugins {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Cpu = 'cpu',
        Disk = 'disk',
        Diskio = 'diskio',
        Docker = 'docker',
        File = 'file',
        Kernel = 'kernel',
        Kubernetes = 'kubernetes',
        Logparser = 'logparser',
        Mem = 'mem',
        NetResponse = 'net_response',
        Net = 'net',
        Ngnix = 'ngnix',
        Processes = 'processes',
        Procstats = 'procstats',
        Prometheus = 'prometheus',
        Redis = 'redis',
        Swap = 'swap',
        Syslog = 'syslog',
        System = 'system',
        Tail = 'tail',
        InfluxdbV2 = 'influxdb_v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input',
        Output = 'output',
        Processor = 'processor',
        Aggregator = 'aggregator'
    }
}

/**
 * 
 * @export
 * @interface Telegrafs
 */
export interface Telegrafs {
    /**
     * 
     * @type {Array<Telegraf>}
     * @memberof Telegrafs
     */
    configurations?: Array<Telegraf>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * if inactive the user is inactive.
     * @type {string}
     * @memberof User
     */
    status?: User.StatusEnum;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {MacroLinks}
     * @memberof UserResponse
     */
    links?: MacroLinks;
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    user?: User;
}

/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {MacroLinks}
     * @memberof Users
     */
    links?: MacroLinks;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof Users
     */
    users?: Array<UserResponse>;
}

/**
 * 
 * @export
 * @interface V1ViewProperties
 */
export interface V1ViewProperties {
    /**
     * 
     * @type {V1ViewPropertiesAxes}
     * @memberof V1ViewProperties
     */
    axes?: V1ViewPropertiesAxes;
    /**
     * Colors define color encoding of data into a visualization
     * @type {Array<DashboardColor>}
     * @memberof V1ViewProperties
     */
    colors?: Array<DashboardColor>;
    /**
     * 
     * @type {V1ViewPropertiesDecimalPoints}
     * @memberof V1ViewProperties
     */
    decimalPoints?: V1ViewPropertiesDecimalPoints;
    /**
     * fieldOptions represent the fields retrieved by the query with customization options
     * @type {Array<RenamableField>}
     * @memberof V1ViewProperties
     */
    fieldOptions?: Array<RenamableField>;
    /**
     * The viewport for a view's graph/visualization
     * @type {string}
     * @memberof V1ViewProperties
     */
    graphType?: V1ViewProperties.GraphTypeEnum;
    /**
     * 
     * @type {V1ViewPropertiesLegend}
     * @memberof V1ViewProperties
     */
    legend?: V1ViewPropertiesLegend;
    /**
     * 
     * @type {Array<DashboardQuery>}
     * @memberof V1ViewProperties
     */
    queries?: Array<DashboardQuery>;
    /**
     * 
     * @type {any}
     * @memberof V1ViewProperties
     */
    tableOptions?: any;
    /**
     * timeFormat describes the display format for time values according to moment.js date formatting
     * @type {string}
     * @memberof V1ViewProperties
     */
    timeFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ViewProperties
     */
    type?: V1ViewProperties.TypeEnum;
}

/**
 * @export
 * @namespace V1ViewProperties
 */
export namespace V1ViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum GraphTypeEnum {
        SingleStat = 'single-stat',
        Line = 'line',
        LinePlusSingleStat = 'line-plus-single-stat',
        LineStacked = 'line-stacked',
        LineStepplot = 'line-stepplot',
        Bar = 'bar',
        Gauge = 'gauge',
        Table = 'table'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ChronografV1 = 'chronograf-v1'
    }
}

/**
 * The viewport for a View's visualizations
 * @export
 * @interface V1ViewPropertiesAxes
 */
export interface V1ViewPropertiesAxes {
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    _true?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    x?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof V1ViewPropertiesAxes
     */
    y2?: Axis;
}

/**
 * decimal points indicates whether and how many digits to show after decimal point
 * @export
 * @interface V1ViewPropertiesDecimalPoints
 */
export interface V1ViewPropertiesDecimalPoints {
    /**
     * The number of digists after decimal to display
     * @type {number}
     * @memberof V1ViewPropertiesDecimalPoints
     */
    digits?: number;
    /**
     * Indicates whether decimal point setting should be enforced
     * @type {boolean}
     * @memberof V1ViewPropertiesDecimalPoints
     */
    isEnforced?: boolean;
}

/**
 * Legend define encoding of data into a view's legend
 * @export
 * @interface V1ViewPropertiesLegend
 */
export interface V1ViewPropertiesLegend {
    /**
     * orientation is the location of the legend with respect to the view graph
     * @type {string}
     * @memberof V1ViewPropertiesLegend
     */
    orientation?: V1ViewPropertiesLegend.OrientationEnum;
    /**
     * type is the style of the legend
     * @type {string}
     * @memberof V1ViewPropertiesLegend
     */
    type?: V1ViewPropertiesLegend.TypeEnum;
}

/**
 * @export
 * @namespace V1ViewPropertiesLegend
 */
export namespace V1ViewPropertiesLegend {
    /**
     * @export
     * @enum {string}
     */
    export enum OrientationEnum {
        Top = 'top',
        Bottom = 'bottom',
        Left = 'left',
        Right = 'right'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Static = 'static'
    }
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    id?: string;
    /**
     * 
     * @type {SourceLinks}
     * @memberof View
     */
    links?: SourceLinks;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof View
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface Views
 */
export interface Views {
    /**
     * 
     * @type {SourceLinks}
     * @memberof Views
     */
    links?: SourceLinks;
    /**
     * 
     * @type {Array<View>}
     * @memberof Views
     */
    views?: Array<View>;
}


/**
 * AuthorizationsApi - axios parameter creator
 * @export
 */
export const AuthorizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDDelete.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDGet.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling authorizationsAuthIDPatch.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling authorizationsAuthIDPatch.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Authorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorization || {}) : (authorization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options: any = {}): RequestArgs {
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userID !== undefined) {
                localVarQueryParameter['userID'] = userID;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling authorizationsPost.');
            }
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Authorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorization || {}) : (authorization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationsApi - functional programming interface
 * @export
 */
export const AuthorizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDDelete(authID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDGet(authID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsAuthIDPatch(authID, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorizations> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsGet(userID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).authorizationsPost(authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthorizationsApi - factory interface
 * @export
 */
export const AuthorizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDDelete(authID: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDDelete(authID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDGet(authID: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDGet(authID, options)(axios, basePath);
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {Authorization} authorization authorization to update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsAuthIDPatch(authID, authorization, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userID?: string, user?: string, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsGet(userID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsPost(authorization: Authorization, options?: any) {
            return AuthorizationsApiFp(configuration).authorizationsPost(authorization, options)(axios, basePath);
        },
    };
};

/**
 * AuthorizationsApi - object-oriented interface
 * @export
 * @class AuthorizationsApi
 * @extends {BaseAPI}
 */
export class AuthorizationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a authorization
     * @param {string} authID ID of authorization to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDDelete(authID: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDDelete(authID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an authorization
     * @param {string} authID ID of authorization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDGet(authID: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDGet(authID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
     * @param {string} authID ID of authorization to update
     * @param {Authorization} authorization authorization to update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsAuthIDPatch(authID: string, authorization: Authorization, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsAuthIDPatch(authID, authorization, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all authorizations
     * @param {string} [userID] filter authorizations belonging to a user id
     * @param {string} [user] filter authorizations belonging to a user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsGet(userID?: string, user?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsGet(userID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an authorization
     * @param {Authorization} authorization authorization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public authorizationsPost(authorization: Authorization, options?: any) {
        return AuthorizationsApiFp(this.configuration).authorizationsPost(authorization, options)(this.axios, this.basePath);
    }

}

/**
 * BucketsApi - axios parameter creator
 * @export
 */
export const BucketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDGet.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDPatch.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling bucketsBucketIDPatch.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bucketsGet.');
            }
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bucketsPost.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling bucketsPost.');
            }
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BucketsApi - functional programming interface
 * @export
 */
export const BucketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsBucketIDPatch(bucketID, bucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).bucketsPost(org, bucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).sourcesSourceIDBucketsGet(sourceID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * BucketsApi - factory interface
 * @export
 */
export const BucketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any) {
            return BucketsApiFp(configuration).bucketsBucketIDPatch(bucketID, bucket, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsGet(org: string, options?: any) {
            return BucketsApiFp(configuration).bucketsGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a bucket
         * @param {string} org specifies the organization of the resource
         * @param {Bucket} bucket bucket to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsPost(org: string, bucket: Bucket, options?: any) {
            return BucketsApiFp(configuration).bucketsPost(org, bucket, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
            return BucketsApiFp(configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(axios, basePath);
        },
    };
};

/**
 * BucketsApi - object-oriented interface
 * @export
 * @class BucketsApi
 * @extends {BaseAPI}
 */
export class BucketsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a bucket
     * @param {string} bucketID ID of bucket to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a bucket
     * @param {string} bucketID ID of bucket to update
     * @param {Bucket} bucket bucket update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsBucketIDPatch(bucketID: string, bucket: Bucket, options?: any) {
        return BucketsApiFp(this.configuration).bucketsBucketIDPatch(bucketID, bucket, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all buckets
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsGet(org: string, options?: any) {
        return BucketsApiFp(this.configuration).bucketsGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a bucket
     * @param {string} org specifies the organization of the resource
     * @param {Bucket} bucket bucket to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucketsPost(org: string, bucket: Bucket, options?: any) {
        return BucketsApiFp(this.configuration).bucketsPost(org, bucket, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
        return BucketsApiFp(this.configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(this.axios, this.basePath);
    }

}

/**
 * CellsApi - axios parameter creator
 * @export
 */
export const CellsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellsApi - functional programming interface
 * @export
 */
export const CellsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CellsApi - factory interface
 * @export
 */
export const CellsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
            return CellsApiFp(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(axios, basePath);
        },
    };
};

/**
 * CellsApi - object-oriented interface
 * @export
 * @class CellsApi
 * @extends {BaseAPI}
 */
export class CellsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
        return CellsApiFp(this.configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(this.axios, this.basePath);
    }

}

/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling dashboardsDashboardIDCellsCellIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling dashboardsDashboardIDCellsPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling dashboardsDashboardIDCellsPut.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDPatch.');
            }
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling dashboardsDashboardIDPatch.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {string} org specifies the organization of the resource
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(org: string, dashboard: Dashboard, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling dashboardsPost.');
            }
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling dashboardsPost.');
            }
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDDelete(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboards> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsGet(owner, sortBy, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {string} org specifies the organization of the resource
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(org: string, dashboard: Dashboard, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).dashboardsPost(org, dashboard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDDelete(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDDelete(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any) {
            return DashboardsApiFp(configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsGet(owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any) {
            return DashboardsApiFp(configuration).dashboardsGet(owner, sortBy, id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {string} org specifies the organization of the resource
         * @param {Dashboard} dashboard dashboard to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsPost(org: string, dashboard: Dashboard, options?: any) {
            return DashboardsApiFp(configuration).dashboardsPost(org, dashboard, options)(axios, basePath);
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDDelete(dashboardID: string, cellID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDDelete(dashboardID, cellID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsCellIDPatch(dashboardID: string, cellID: string, cellUpdate: CellUpdate, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsCellIDPatch(dashboardID, cellID, cellUpdate, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsPost(dashboardID: string, createCell: CreateCell, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsPost(dashboardID, createCell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDCellsPut(dashboardID: string, cell: Array<Cell>, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDCellsPut(dashboardID, cell, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDDelete(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDDelete(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a single Dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {Dashboard} dashboard patching of a dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsDashboardIDPatch(dashboardID: string, dashboard: Dashboard, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsDashboardIDPatch(dashboardID, dashboard, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all dashboards
     * @param {string} [owner] specifies the owner id to return resources for
     * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
     * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsGet(owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsGet(owner, sortBy, id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard
     * @param {string} org specifies the organization of the resource
     * @param {Dashboard} dashboard dashboard to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardsPost(org: string, dashboard: Dashboard, options?: any) {
        return DashboardsApiFp(this.configuration).dashboardsPost(org, dashboard, options)(this.axios, this.basePath);
    }

}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options: any = {}): RequestArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options: any = {}): RequestArgs {
            const localVarPath = `/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options: any = {}): RequestArgs {
            const localVarPath = `/signout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Routes> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).rootGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).signinPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).signoutPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any) {
            return DefaultApiFp(configuration).rootGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(options?: any) {
            return DefaultApiFp(configuration).signinPost(options)(axios, basePath);
        },
        /**
         * 
         * @summary Expire the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any) {
            return DefaultApiFp(configuration).signoutPost(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Map of all top level routes available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: any) {
        return DefaultApiFp(this.configuration).rootGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Exchange basic auth credentials for session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signinPost(options?: any) {
        return DefaultApiFp(this.configuration).signinPost(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Expire the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signoutPost(options?: any) {
        return DefaultApiFp(this.configuration).signoutPost(options)(this.axios, this.basePath);
    }

}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options: any = {}): RequestArgs {
            const localVarPath = `/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health> {
            const localVarAxiosArgs = HealthApiAxiosParamCreator(configuration).healthGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the health of an instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any) {
            return HealthApiFp(configuration).healthGet(options)(axios, basePath);
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Get the health of an instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthGet(options?: any) {
        return HealthApiFp(this.configuration).healthGet(options)(this.axios, this.basePath);
    }

}

/**
 * MacrosApi - axios parameter creator
 * @export
 */
export const MacrosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosGet.');
            }
            const localVarPath = `/macros`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosMacroIDDelete.');
            }
            // verify required parameter 'macroID' is not null or undefined
            if (macroID === null || macroID === undefined) {
                throw new RequiredError('macroID','Required parameter macroID was null or undefined when calling macrosMacroIDDelete.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosMacroIDDelete.');
            }
            const localVarPath = `/macros/{macroID}`
                .replace(`{${"macroID"}}`, encodeURIComponent(String(macroID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosMacroIDPatch.');
            }
            // verify required parameter 'macroID' is not null or undefined
            if (macroID === null || macroID === undefined) {
                throw new RequiredError('macroID','Required parameter macroID was null or undefined when calling macrosMacroIDPatch.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosMacroIDPatch.');
            }
            const localVarPath = `/macros/{macroID}`
                .replace(`{${"macroID"}}`, encodeURIComponent(String(macroID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling macrosPost.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling macrosPost.');
            }
            const localVarPath = `/macros`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MacrosApi - functional programming interface
 * @export
 */
export const MacrosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosGet(authorization, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosMacroIDDelete(authorization, macroID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosMacroIDPatch(authorization, macroID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Macros> {
            const localVarAxiosArgs = MacrosApiAxiosParamCreator(configuration).macrosPost(authorization, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * MacrosApi - factory interface
 * @export
 */
export const MacrosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosGet(authorization: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosGet(authorization, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosMacroIDDelete(authorization, macroID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} macroID id of the macro
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosMacroIDPatch(authorization, macroID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary keywords that specify how input data gets mapped to a replacement output sequence
         * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} org filter macros to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        macrosPost(authorization: string, org: string, options?: any) {
            return MacrosApiFp(configuration).macrosPost(authorization, org, options)(axios, basePath);
        },
    };
};

/**
 * MacrosApi - object-oriented interface
 * @export
 * @class MacrosApi
 * @extends {BaseAPI}
 */
export class MacrosApi extends BaseAPI {
    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosGet(authorization: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosGet(authorization, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} macroID id of the macro
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosMacroIDDelete(authorization: string, macroID: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosMacroIDDelete(authorization, macroID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} macroID id of the macro
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosMacroIDPatch(authorization: string, macroID: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosMacroIDPatch(authorization, macroID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary keywords that specify how input data gets mapped to a replacement output sequence
     * @param {string} authorization the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} org filter macros to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MacrosApi
     */
    public macrosPost(authorization: string, org: string, options?: any) {
        return MacrosApiFp(this.configuration).macrosPost(authorization, org, options)(this.axios, this.basePath);
    }

}

/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options: any = {}): RequestArgs {
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDGet.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersGet.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDMembersPost.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersGet.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDPatch.');
            }
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling orgsOrgIDPatch.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options: any = {}): RequestArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling orgsPost.');
            }
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organizations> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsOrgIDPatch(orgID, organization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).orgsPost(organization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any) {
            return OrganizationsApiFp(configuration).orgsGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDPatch(orgID: string, organization: Organization, options?: any) {
            return OrganizationsApiFp(configuration).orgsOrgIDPatch(orgID, organization, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(organization: Organization, options?: any) {
            return OrganizationsApiFp(configuration).orgsPost(organization, options)(axios, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary List all organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsGet(options?: any) {
        return OrganizationsApiFp(this.configuration).orgsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an organization
     * @param {string} orgID ID of organization to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersGet(orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update an organization
     * @param {string} orgID ID of organization to get
     * @param {Organization} organization organization update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsOrgIDPatch(orgID: string, organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsOrgIDPatch(orgID, organization, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an organization
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsPost(organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).orgsPost(organization, options)(this.axios, this.basePath);
    }

}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/ast`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(languageRequest || {}) : (languageRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query influx with specified return formatting. The spec and query fields are mutually exclusive.
         * @param {string} org specifies the organization of the resource
         * @param {string} query query script to execute.
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGet(org: string, query: string, authorization?: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling queryGet.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling queryGet.');
            }
            const localVarPath = `/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * analyzes flux query or specification and generates a query plan.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {PlanRequest} [planRequest] flux query or specification to generate plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPlanPost(contentType?: 'application/json', authorization?: string, planRequest?: PlanRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/plan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlanRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(planRequest || {}) : (planRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json', authorization?: string, org?: string, query?: Query, options: any = {}): RequestArgs {
            const localVarPath = `/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/spec`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(languageRequest || {}) : (languageRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options: any = {}): RequestArgs {
            const localVarPath = `/query/suggestions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling querySuggestionsNameGet.');
            }
            const localVarPath = `/query/suggestions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryAstPost(contentType, authorization, languageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary query influx with specified return formatting. The spec and query fields are mutually exclusive.
         * @param {string} org specifies the organization of the resource
         * @param {string} query query script to execute.
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGet(org: string, query: string, authorization?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryGet(org, query, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * analyzes flux query or specification and generates a query plan.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {PlanRequest} [planRequest] flux query or specification to generate plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPlanPost(contentType?: 'application/json', authorization?: string, planRequest?: PlanRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanResponse> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryPlanPost(contentType, authorization, planRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json', authorization?: string, org?: string, query?: Query, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).queryPost(accept, contentType, authorization, org, query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySpecification> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySpecPost(contentType, authorization, languageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySuggestionsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).querySuggestionsNameGet(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
            return QueryApiFp(configuration).queryAstPost(contentType, authorization, languageRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary query influx with specified return formatting. The spec and query fields are mutually exclusive.
         * @param {string} org specifies the organization of the resource
         * @param {string} query query script to execute.
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGet(org: string, query: string, authorization?: string, options?: any) {
            return QueryApiFp(configuration).queryGet(org, query, authorization, options)(axios, basePath);
        },
        /**
         * analyzes flux query or specification and generates a query plan.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {PlanRequest} [planRequest] flux query or specification to generate plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPlanPost(contentType?: 'application/json', authorization?: string, planRequest?: PlanRequest, options?: any) {
            return QueryApiFp(configuration).queryPlanPost(contentType, authorization, planRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary query an influx
         * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {string} [org] specifies the name of the organization executing the query.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json', authorization?: string, org?: string, query?: Query, options?: any) {
            return QueryApiFp(configuration).queryPost(accept, contentType, authorization, org, query, options)(axios, basePath);
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {'application/json'} [contentType] 
         * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
            return QueryApiFp(configuration).querySpecPost(contentType, authorization, languageRequest, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsGet(options?: any) {
            return QueryApiFp(configuration).querySuggestionsGet(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySuggestionsNameGet(name: string, options?: any) {
            return QueryApiFp(configuration).querySuggestionsNameGet(name, options)(axios, basePath);
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * analyzes flux query and generates a query specification.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryAstPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
        return QueryApiFp(this.configuration).queryAstPost(contentType, authorization, languageRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary query influx with specified return formatting. The spec and query fields are mutually exclusive.
     * @param {string} org specifies the organization of the resource
     * @param {string} query query script to execute.
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryGet(org: string, query: string, authorization?: string, options?: any) {
        return QueryApiFp(this.configuration).queryGet(org, query, authorization, options)(this.axios, this.basePath);
    }

    /**
     * analyzes flux query or specification and generates a query plan.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {PlanRequest} [planRequest] flux query or specification to generate plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryPlanPost(contentType?: 'application/json', authorization?: string, planRequest?: PlanRequest, options?: any) {
        return QueryApiFp(this.configuration).queryPlanPost(contentType, authorization, planRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary query an influx
     * @param {'text/csv' | 'application/vnd.influx.arrow'} [accept] specifies the return content format. Each response content type will have its own dialect options.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {string} [org] specifies the name of the organization executing the query.
     * @param {Query} [query] flux query or specification to execute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public queryPost(accept?: 'text/csv' | 'application/vnd.influx.arrow', contentType?: 'application/json', authorization?: string, org?: string, query?: Query, options?: any) {
        return QueryApiFp(this.configuration).queryPost(accept, contentType, authorization, org, query, options)(this.axios, this.basePath);
    }

    /**
     * analyzes flux query and generates a query specification.
     * @param {'application/json'} [contentType] 
     * @param {string} [authorization] the authorization header should be in the format of &#x60;Token &lt;key&gt;&#x60;
     * @param {LanguageRequest} [languageRequest] analyzed flux query to generate specification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySpecPost(contentType?: 'application/json', authorization?: string, languageRequest?: LanguageRequest, options?: any) {
        return QueryApiFp(this.configuration).querySpecPost(contentType, authorization, languageRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySuggestionsGet(options?: any) {
        return QueryApiFp(this.configuration).querySuggestionsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} name name of branching suggestion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querySuggestionsNameGet(name: string, options?: any) {
        return QueryApiFp(this.configuration).querySuggestionsNameGet(name, options)(this.axios, this.basePath);
    }

}

/**
 * SetupApi - axios parameter creator
 * @export
 */
export const SetupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options: any = {}): RequestArgs {
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options: any = {}): RequestArgs {
            // verify required parameter 'onboardingRequest' is not null or undefined
            if (onboardingRequest === null || onboardingRequest === undefined) {
                throw new RequiredError('onboardingRequest','Required parameter onboardingRequest was null or undefined when calling setupPost.');
            }
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OnboardingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(onboardingRequest || {}) : (onboardingRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsOnboarding> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).setupGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingResponse> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).setupPost(onboardingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupGet(options?: any) {
            return SetupApiFp(configuration).setupGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPost(onboardingRequest: OnboardingRequest, options?: any) {
            return SetupApiFp(configuration).setupPost(onboardingRequest, options)(axios, basePath);
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * 
     * @summary check if database has default user, org, bucket created, returns true if not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupGet(options?: any) {
        return SetupApiFp(this.configuration).setupGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary post onboarding request, to setup initial user, org and bucket
     * @param {OnboardingRequest} onboardingRequest source to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public setupPost(onboardingRequest: OnboardingRequest, options?: any) {
        return SetupApiFp(this.configuration).setupPost(onboardingRequest, options)(this.axios, this.basePath);
    }

}

/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesGet.');
            }
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesPost.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling sourcesPost.');
            }
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling sourcesSourceIDBucketsGet.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDGet.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDHealthGet.');
            }
            const localVarPath = `/sources/{sourceID}/health`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling sourcesSourceIDPatch.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling sourcesSourceIDPatch.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sources> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesPost(org, source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDBucketsGet(sourceID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDGet(sourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDHealthGet(sourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).sourcesSourceIDPatch(sourceID, source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all sources
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesGet(org: string, options?: any) {
            return SourcesApiFp(configuration).sourcesGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a Source
         * @param {string} org specifies the organization of the resource
         * @param {Source} source source to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesPost(org: string, source: Source, options?: any) {
            return SourcesApiFp(configuration).sourcesPost(org, source, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDGet(sourceID: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDGet(sourceID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDHealthGet(sourceID: string, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDHealthGet(sourceID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesSourceIDPatch(sourceID: string, source: Source, options?: any) {
            return SourcesApiFp(configuration).sourcesSourceIDPatch(sourceID, source, options)(axios, basePath);
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get all sources
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesGet(org: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a Source
     * @param {string} org specifies the organization of the resource
     * @param {Source} source source to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesPost(org: string, source: Source, options?: any) {
        return SourcesApiFp(this.configuration).sourcesPost(org, source, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDBucketsGet(sourceID: string, org: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDBucketsGet(sourceID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a source
     * @param {string} sourceID ID of the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDGet(sourceID: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDGet(sourceID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources health
     * @param {string} sourceID ID of the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDHealthGet(sourceID: string, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDHealthGet(sourceID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Updates a Source
     * @param {string} sourceID ID of the source
     * @param {Source} source source update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sourcesSourceIDPatch(sourceID: string, source: Source, options?: any) {
        return SourcesApiFp(this.configuration).sourcesSourceIDPatch(sourceID, source, options)(this.axios, this.basePath);
    }

}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'taskCreateRequest' is not null or undefined
            if (taskCreateRequest === null || taskCreateRequest === undefined) {
                throw new RequiredError('taskCreateRequest','Required parameter taskCreateRequest was null or undefined when calling tasksPost.');
            }
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskCreateRequest || {}) : (taskCreateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDGet.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDLogsGet.');
            }
            const localVarPath = `/tasks/{taskID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersGet.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDMembersPost.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersGet.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            const localVarPath = `/tasks/taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, taskUpdateRequest: TaskUpdateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDPatch.');
            }
            // verify required parameter 'taskUpdateRequest' is not null or undefined
            if (taskUpdateRequest === null || taskUpdateRequest === undefined) {
                throw new RequiredError('taskUpdateRequest','Required parameter taskUpdateRequest was null or undefined when calling tasksTaskIDPatch.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskUpdateRequest || {}) : (taskUpdateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['afterTime'] = (afterTime as any).toISOString();
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['beforeTime'] = (beforeTime as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDGet.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDLogsGet.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDLogsGet.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDRunsRunIDRetryPost.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling tasksTaskIDRunsRunIDRetryPost.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/retry`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksGet(after, user, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksPost(taskCreateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDDelete(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDLogsGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, taskUpdateRequest: TaskUpdateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDPatch(taskID, taskUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Lists tasks, limit 100
         * @summary List tasks.
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user name
         * @param {string} [org] filter tasks to a specific organization name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(after?: string, user?: string, org?: string, options?: any) {
            return TasksApiFp(configuration).tasksGet(after, user, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPost(taskCreateRequest: TaskCreateRequest, options?: any) {
            return TasksApiFp(configuration).tasksPost(taskCreateRequest, options)(axios, basePath);
        },
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDDelete(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDDelete(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDLogsGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDLogsGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDPatch(taskID: string, taskUpdateRequest: TaskUpdateRequest, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDPatch(taskID, taskUpdateRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any) {
            return TasksApiFp(configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options)(axios, basePath);
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Lists tasks, limit 100
     * @summary List tasks.
     * @param {string} [after] returns tasks after specified ID
     * @param {string} [user] filter tasks to a specific user name
     * @param {string} [org] filter tasks to a specific organization name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGet(after?: string, user?: string, org?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGet(after, user, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a new task
     * @param {TaskCreateRequest} taskCreateRequest task to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPost(taskCreateRequest: TaskCreateRequest, options?: any) {
        return TasksApiFp(this.configuration).tasksPost(taskCreateRequest, options)(this.axios, this.basePath);
    }

    /**
     * Deletes a task and all associated records
     * @summary Delete a task
     * @param {string} taskID ID of task to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDDelete(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDDelete(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an task
     * @param {string} taskID ID of task to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a task
     * @param {string} taskID ID of task to get logs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDLogsGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDLogsGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersGet(taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * Update a task. This will cancel all queued runs.
     * @summary Update a task
     * @param {string} taskID ID of task to get
     * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDPatch(taskID: string, taskUpdateRequest: TaskUpdateRequest, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDPatch(taskID, taskUpdateRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve list of run records for a task
     * @param {string} taskID ID of task to get runs for
     * @param {string} [after] returns runs after specified ID
     * @param {number} [limit] the number of runs to return
     * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
     * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsGet(taskID: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsGet(taskID, after, limit, afterTime, beforeTime, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a single run record for a task
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDGet(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDGet(taskID, runID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a run
     * @param {string} taskID ID of task to get logs for.
     * @param {string} runID ID of run to get logs for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDLogsGet(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDLogsGet(taskID, runID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retry a task run
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIDRunsRunIDRetryPost(taskID: string, runID: string, options?: any) {
        return TasksApiFp(this.configuration).tasksTaskIDRunsRunIDRetryPost(taskID, runID, options)(this.axios, this.basePath);
    }

}

/**
 * TelegrafsApi - axios parameter creator
 * @export
 */
export const TelegrafsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling telegrafsGet.');
            }
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {string} org specifies the organization of the resource
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(org: string, telegrafRequest: TelegrafRequest, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling telegrafsPost.');
            }
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling telegrafsPost.');
            }
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDPut.');
            }
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling telegrafsTelegrafIDPut.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegrafsApi - functional programming interface
 * @export
 */
export const TelegrafsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegrafs> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {string} org specifies the organization of the resource
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(org: string, telegrafRequest: TelegrafRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsPost(org, telegrafRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TelegrafsApi - factory interface
 * @export
 */
export const TelegrafsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsGet(org: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {string} org specifies the organization of the resource
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsPost(org: string, telegrafRequest: TelegrafRequest, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsPost(org, telegrafRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any) {
            return TelegrafsApiFp(configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options)(axios, basePath);
        },
    };
};

/**
 * TelegrafsApi - object-oriented interface
 * @export
 * @class TelegrafsApi
 * @extends {BaseAPI}
 */
export class TelegrafsApi extends BaseAPI {
    /**
     * 
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsGet(org: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a telegraf config
     * @param {string} org specifies the organization of the resource
     * @param {TelegrafRequest} telegrafRequest telegraf config to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsPost(org: string, telegrafRequest: TelegrafRequest, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsPost(org, telegrafRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public telegrafsTelegrafIDPut(telegrafID: string, telegrafRequest: TelegrafRequest, options?: any) {
        return TelegrafsApiFp(this.configuration).telegrafsTelegrafIDPut(telegrafID, telegrafRequest, options)(this.axios, this.basePath);
    }

}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDMembersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDMembersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersGet.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling bucketsBucketIDOwnersPost.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling bucketsBucketIDOwnersUserIDDelete.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDMembersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDMembersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersGet.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dashboardsDashboardIDOwnersPost.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling dashboardsDashboardIDOwnersUserIDDelete.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options: any = {}): RequestArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options: any = {}): RequestArgs {
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling mePasswordPut.');
            }
            const localVarPath = `/me/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersGet.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDMembersPost.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDMembersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersGet.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling orgsOrgIDOwnersPost.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling orgsOrgIDOwnersUserIDDelete.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersGet.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDMembersPost.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDMembersUserIDDelete.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersGet.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling tasksTaskIDOwnersPost.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling tasksTaskIDOwnersUserIDDelete.');
            }
            const localVarPath = `/tasks/taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDMembersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDMembersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersGet.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling telegrafsTelegrafIDOwnersPost.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling telegrafsTelegrafIDOwnersUserIDDelete.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options: any = {}): RequestArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling usersPost.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDDelete.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDGet.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDPasswordPut.');
            }
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling usersUserIDPasswordPut.');
            }
            const localVarPath = `/users/{userID}/password`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling usersUserIDPatch.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling usersUserIDPatch.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersGet.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDMembersPost.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersGet.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDOwnersPost.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersGet(bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersPost(bucketID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).meGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).mePasswordPut(passwordResetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersGet(orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersPost(orgID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersGet(taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersPost(taskID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersPost(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDDelete(userID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDGet(userID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDPasswordPut(userID, passwordResetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIDPatch(userID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersGet(bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersGet(bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
            return UsersApiFp(configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
            return UsersApiFp(configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: any) {
            return UsersApiFp(configuration).meGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordPut(passwordResetBody: PasswordResetBody, options?: any) {
            return UsersApiFp(configuration).mePasswordPut(passwordResetBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersGet(orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersGet(orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersGet(orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersPost(orgID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
            return UsersApiFp(configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersGet(taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersGet(taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersGet(taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersPost(taskID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
            return UsersApiFp(configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
            return UsersApiFp(configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any) {
            return UsersApiFp(configuration).usersGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options?: any) {
            return UsersApiFp(configuration).usersPost(user, options)(axios, basePath);
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDDelete(userID: string, options?: any) {
            return UsersApiFp(configuration).usersUserIDDelete(userID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID: string, options?: any) {
            return UsersApiFp(configuration).usersUserIDGet(userID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any) {
            return UsersApiFp(configuration).usersUserIDPasswordPut(userID, passwordResetBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDPatch(userID: string, user: User, options?: any) {
            return UsersApiFp(configuration).usersUserIDPatch(userID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
            return UsersApiFp(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersGet(bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersPost(bucketID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDMembersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDMembersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersGet(bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersGet(bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersPost(bucketID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersPost(bucketID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bucketsBucketIDOwnersUserIDDelete(userID: string, bucketID: string, options?: any) {
        return UsersApiFp(this.configuration).bucketsBucketIDOwnersUserIDDelete(userID, bucketID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersGet(dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersPost(dashboardID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDMembersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDMembersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersGet(dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersGet(dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersPost(dashboardID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersPost(dashboardID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public dashboardsDashboardIDOwnersUserIDDelete(userID: string, dashboardID: string, options?: any) {
        return UsersApiFp(this.configuration).dashboardsDashboardIDOwnersUserIDDelete(userID, dashboardID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public meGet(options?: any) {
        return UsersApiFp(this.configuration).meGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public mePasswordPut(passwordResetBody: PasswordResetBody, options?: any) {
        return UsersApiFp(this.configuration).mePasswordPut(passwordResetBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersGet(orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersPost(orgID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDMembersUserIDDelete(userID: string, orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDMembersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersGet(orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersGet(orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersPost(orgID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersPost(orgID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public orgsOrgIDOwnersUserIDDelete(userID: string, orgID: string, options?: any) {
        return UsersApiFp(this.configuration).orgsOrgIDOwnersUserIDDelete(userID, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersGet(taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersPost(taskID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDMembersUserIDDelete(userID: string, taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDMembersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersGet(taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersGet(taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersPost(taskID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersPost(taskID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tasksTaskIDOwnersUserIDDelete(userID: string, taskID: string, options?: any) {
        return UsersApiFp(this.configuration).tasksTaskIDOwnersUserIDDelete(userID, taskID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersGet(telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersPost(telegrafID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDMembersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDMembersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersGet(telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersGet(telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersPost(telegrafID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersPost(telegrafID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public telegrafsTelegrafIDOwnersUserIDDelete(userID: string, telegrafID: string, options?: any) {
        return UsersApiFp(this.configuration).telegrafsTelegrafIDOwnersUserIDDelete(userID, telegrafID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(options?: any) {
        return UsersApiFp(this.configuration).usersGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(user: User, options?: any) {
        return UsersApiFp(this.configuration).usersPost(user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary deletes a user
     * @param {string} userID ID of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDDelete(userID: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDDelete(userID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a user
     * @param {string} userID ID of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDGet(userID: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDGet(userID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {string} userID ID of the user
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDPasswordPut(userID: string, passwordResetBody: PasswordResetBody, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDPasswordPut(userID, passwordResetBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a user
     * @param {string} userID ID of user to update
     * @param {User} user user update to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIDPatch(userID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).usersUserIDPatch(userID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view members
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersGet(viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view member
     * @param {string} viewID ID of the view
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an view
     * @param {string} userID ID of member to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view owners
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersGet(viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view owner
     * @param {string} viewID ID of the view
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a view
     * @param {string} userID ID of owner to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
        return UsersApiFp(this.configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

}

/**
 * ViewsApi - axios parameter creator
 * @export
 */
export const ViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling viewsGet.');
            }
            const localVarPath = `/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling viewsPost.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling viewsPost.');
            }
            const localVarPath = `/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDDelete.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDGet.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersGet.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDMembersPost.');
            }
            const localVarPath = `/views/{viewID}/members`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDMembersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersGet.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersPost.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling viewsViewIDOwnersPost.');
            }
            const localVarPath = `/views/{viewID}/owners`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDOwnersUserIDDelete.');
            }
            const localVarPath = `/views/{viewID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options: any = {}): RequestArgs {
            // verify required parameter 'viewID' is not null or undefined
            if (viewID === null || viewID === undefined) {
                throw new RequiredError('viewID','Required parameter viewID was null or undefined when calling viewsViewIDPatch.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling viewsViewIDPatch.');
            }
            const localVarPath = `/views/{viewID}`
                .replace(`{${"viewID"}}`, encodeURIComponent(String(viewID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Views> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsGet(org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsPost(org, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDDelete(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersGet(viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersPost(viewID, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).viewsViewIDPatch(viewID, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all views
         * @param {string} org specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(org: string, options?: any) {
            return ViewsApiFp(configuration).viewsGet(org, options)(axios, basePath);
        },
        /**
         * 
         * @summary A view contains information about the visual representation of data
         * @param {string} org specifies the organization of the resource
         * @param {View} view view to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(org: string, view: View, options?: any) {
            return ViewsApiFp(configuration).viewsPost(org, view, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a view
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDDelete(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDDelete(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a single View
         * @param {string} viewID ID of view to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view members
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view member
         * @param {string} viewID ID of the view
         * @param {User} user user to add as member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an view
         * @param {string} userID ID of member to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all view owners
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersGet(viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersGet(viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add view owner
         * @param {string} viewID ID of the view
         * @param {User} user user to add as owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersPost(viewID, user, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a view
         * @param {string} userID ID of owner to remove
         * @param {string} viewID ID of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single view
         * @param {string} viewID ID of view to update
         * @param {View} view patching of a view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsViewIDPatch(viewID: string, view: View, options?: any) {
            return ViewsApiFp(configuration).viewsViewIDPatch(viewID, view, options)(axios, basePath);
        },
    };
};

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * 
     * @summary Get all views
     * @param {string} org specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsGet(org: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsGet(org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary A view contains information about the visual representation of data
     * @param {string} org specifies the organization of the resource
     * @param {View} view view to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsPost(org: string, view: View, options?: any) {
        return ViewsApiFp(this.configuration).viewsPost(org, view, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a view
     * @param {string} viewID ID of view to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDDelete(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDDelete(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a single View
     * @param {string} viewID ID of view to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view members
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view member
     * @param {string} viewID ID of the view
     * @param {User} user user to add as member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersPost(viewID: string, user: User, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an view
     * @param {string} userID ID of member to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDMembersUserIDDelete(userID: string, viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDMembersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all view owners
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersGet(viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersGet(viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add view owner
     * @param {string} viewID ID of the view
     * @param {User} user user to add as owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersPost(viewID: string, user: User, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersPost(viewID, user, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a view
     * @param {string} userID ID of owner to remove
     * @param {string} viewID ID of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDOwnersUserIDDelete(userID: string, viewID: string, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDOwnersUserIDDelete(userID, viewID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single view
     * @param {string} viewID ID of view to update
     * @param {View} view patching of a view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsViewIDPatch(viewID: string, view: View, options?: any) {
        return ViewsApiFp(this.configuration).viewsViewIDPatch(viewID, view, options)(this.axios, this.basePath);
    }

}

/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {'ns' | 'us' | 'u' | 'ms' | 's'} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: 'ns' | 'us' | 'u' | 'ms' | 's', options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling writePost.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling writePost.');
            }
            const localVarPath = `/write`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }

            if (contentEncoding !== undefined && contentEncoding !== null) {
                localVarHeaderParameter['Content-Encoding'] = String(contentEncoding);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (contentLength !== undefined && contentLength !== null) {
                localVarHeaderParameter['Content-Length'] = String(contentLength);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {'ns' | 'us' | 'u' | 'ms' | 's'} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: 'ns' | 'us' | 'u' | 'ms' | 's', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WriteApiAxiosParamCreator(configuration).writePost(org, bucket, contentEncoding, contentType, contentLength, accept, precision, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {'ns' | 'us' | 'u' | 'ms' | 's'} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writePost(org: string, bucket: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: 'ns' | 'us' | 'u' | 'ms' | 's', options?: any) {
            return WriteApiFp(configuration).writePost(org, bucket, contentEncoding, contentType, contentLength, accept, precision, options)(axios, basePath);
        },
    };
};

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI {
    /**
     * 
     * @summary write time-series data into influxdb
     * @param {string} org specifies the destination organization for writes
     * @param {string} bucket specifies the destination bucket for writes
     * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
     * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
     * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
     * @param {'application/json'} [accept] specifies the return content format.
     * @param {'ns' | 'us' | 'u' | 'ms' | 's'} [precision] specifies the precision for the unix timestamps within the body line-protocol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public writePost(org: string, bucket: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: 'ns' | 'us' | 'u' | 'ms' | 's', options?: any) {
        return WriteApiFp(this.configuration).writePost(org, bucket, contentEncoding, contentType, contentLength, accept, precision, options)(this.axios, this.basePath);
    }

}

