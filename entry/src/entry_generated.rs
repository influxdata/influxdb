// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod influxdata {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod iox {

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod write {

            use std::cmp::Ordering;
            use std::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod v_1 {

                use std::cmp::Ordering;
                use std::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_OPERATION: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_OPERATION: u8 = 2;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_OPERATION: [Operation; 3] =
                    [Operation::NONE, Operation::write, Operation::delete];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct Operation(pub u8);
                #[allow(non_upper_case_globals)]
                impl Operation {
                    pub const NONE: Self = Self(0);
                    pub const write: Self = Self(1);
                    pub const delete: Self = Self(2);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 2;
                    pub const ENUM_VALUES: &'static [Self] =
                        &[Self::NONE, Self::write, Self::delete];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::write => Some("write"),
                            Self::delete => Some("delete"),
                            _ => None,
                        }
                    }
                }
                impl std::fmt::Debug for Operation {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for Operation {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                        Self(b)
                    }
                }

                impl flatbuffers::Push for Operation {
                    type Output = Operation;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        unsafe {
                            flatbuffers::emplace_scalar::<u8>(dst, self.0);
                        }
                    }
                }

                impl flatbuffers::EndianScalar for Operation {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let b = u8::to_le(self.0);
                        Self(b)
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(self) -> Self {
                        let b = u8::from_le(self.0);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for Operation {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for Operation {}
                pub struct OperationUnionTableOffset {}

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_LOGICAL_COLUMN_TYPE: i8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_LOGICAL_COLUMN_TYPE: i8 = 3;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_LOGICAL_COLUMN_TYPE: [LogicalColumnType; 4] = [
                    LogicalColumnType::IOx,
                    LogicalColumnType::Tag,
                    LogicalColumnType::Field,
                    LogicalColumnType::Time,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct LogicalColumnType(pub i8);
                #[allow(non_upper_case_globals)]
                impl LogicalColumnType {
                    pub const IOx: Self = Self(0);
                    pub const Tag: Self = Self(1);
                    pub const Field: Self = Self(2);
                    pub const Time: Self = Self(3);

                    pub const ENUM_MIN: i8 = 0;
                    pub const ENUM_MAX: i8 = 3;
                    pub const ENUM_VALUES: &'static [Self] =
                        &[Self::IOx, Self::Tag, Self::Field, Self::Time];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::IOx => Some("IOx"),
                            Self::Tag => Some("Tag"),
                            Self::Field => Some("Field"),
                            Self::Time => Some("Time"),
                            _ => None,
                        }
                    }
                }
                impl std::fmt::Debug for LogicalColumnType {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for LogicalColumnType {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
                        Self(b)
                    }
                }

                impl flatbuffers::Push for LogicalColumnType {
                    type Output = LogicalColumnType;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        unsafe {
                            flatbuffers::emplace_scalar::<i8>(dst, self.0);
                        }
                    }
                }

                impl flatbuffers::EndianScalar for LogicalColumnType {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let b = i8::to_le(self.0);
                        Self(b)
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(self) -> Self {
                        let b = i8::from_le(self.0);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for LogicalColumnType {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        i8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for LogicalColumnType {}
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_COLUMN_VALUES: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_COLUMN_VALUES: u8 = 6;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_COLUMN_VALUES: [ColumnValues; 7] = [
                    ColumnValues::NONE,
                    ColumnValues::I64Values,
                    ColumnValues::F64Values,
                    ColumnValues::U64Values,
                    ColumnValues::StringValues,
                    ColumnValues::BoolValues,
                    ColumnValues::BytesValues,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct ColumnValues(pub u8);
                #[allow(non_upper_case_globals)]
                impl ColumnValues {
                    pub const NONE: Self = Self(0);
                    pub const I64Values: Self = Self(1);
                    pub const F64Values: Self = Self(2);
                    pub const U64Values: Self = Self(3);
                    pub const StringValues: Self = Self(4);
                    pub const BoolValues: Self = Self(5);
                    pub const BytesValues: Self = Self(6);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 6;
                    pub const ENUM_VALUES: &'static [Self] = &[
                        Self::NONE,
                        Self::I64Values,
                        Self::F64Values,
                        Self::U64Values,
                        Self::StringValues,
                        Self::BoolValues,
                        Self::BytesValues,
                    ];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::I64Values => Some("I64Values"),
                            Self::F64Values => Some("F64Values"),
                            Self::U64Values => Some("U64Values"),
                            Self::StringValues => Some("StringValues"),
                            Self::BoolValues => Some("BoolValues"),
                            Self::BytesValues => Some("BytesValues"),
                            _ => None,
                        }
                    }
                }
                impl std::fmt::Debug for ColumnValues {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for ColumnValues {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                        Self(b)
                    }
                }

                impl flatbuffers::Push for ColumnValues {
                    type Output = ColumnValues;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        unsafe {
                            flatbuffers::emplace_scalar::<u8>(dst, self.0);
                        }
                    }
                }

                impl flatbuffers::EndianScalar for ColumnValues {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let b = u8::to_le(self.0);
                        Self(b)
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(self) -> Self {
                        let b = u8::from_le(self.0);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for ColumnValues {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for ColumnValues {}
                pub struct ColumnValuesUnionTableOffset {}

                pub enum WriteOperationsOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct WriteOperations<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for WriteOperations<'a> {
                    type Inner = WriteOperations<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> WriteOperations<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        WriteOperations { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args WriteOperationsArgs<'args>,
                    ) -> flatbuffers::WIPOffset<WriteOperations<'bldr>> {
                        let mut builder = WriteOperationsBuilder::new(_fbb);
                        if let Some(x) = args.partition_writes {
                            builder.add_partition_writes(x);
                        }
                        builder.finish()
                    }

                    pub const VT_PARTITION_WRITES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn partition_writes(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PartitionWrite<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PartitionWrite>>,
                        >>(
                            WriteOperations::VT_PARTITION_WRITES, None
                        )
                    }
                }

                impl flatbuffers::Verifiable for WriteOperations<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<
                                    '_,
                                    flatbuffers::ForwardsUOffset<PartitionWrite>,
                                >,
                            >>(
                                &"partition_writes", Self::VT_PARTITION_WRITES, false
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct WriteOperationsArgs<'a> {
                    pub partition_writes: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<PartitionWrite<'a>>,
                            >,
                        >,
                    >,
                }
                impl<'a> Default for WriteOperationsArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        WriteOperationsArgs {
                            partition_writes: None,
                        }
                    }
                }
                pub struct WriteOperationsBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> WriteOperationsBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_partition_writes(
                        &mut self,
                        partition_writes: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<PartitionWrite<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            WriteOperations::VT_PARTITION_WRITES,
                            partition_writes,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> WriteOperationsBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        WriteOperationsBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<WriteOperations<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for WriteOperations<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("WriteOperations");
                        ds.field("partition_writes", &self.partition_writes());
                        ds.finish()
                    }
                }
                pub enum DeleteOperationsOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct DeleteOperations<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for DeleteOperations<'a> {
                    type Inner = DeleteOperations<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> DeleteOperations<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        DeleteOperations { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args DeleteOperationsArgs<'args>,
                    ) -> flatbuffers::WIPOffset<DeleteOperations<'bldr>> {
                        let mut builder = DeleteOperationsBuilder::new(_fbb);
                        if let Some(x) = args.deletes {
                            builder.add_deletes(x);
                        }
                        builder.finish()
                    }

                    pub const VT_DELETES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn deletes(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete>>,
                        >>(DeleteOperations::VT_DELETES, None)
                    }
                }

                impl flatbuffers::Verifiable for DeleteOperations<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Delete>>,
                            >>(&"deletes", Self::VT_DELETES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct DeleteOperationsArgs<'a> {
                    pub deletes: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for DeleteOperationsArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        DeleteOperationsArgs { deletes: None }
                    }
                }
                pub struct DeleteOperationsBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> DeleteOperationsBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_deletes(
                        &mut self,
                        deletes: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Delete<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            DeleteOperations::VT_DELETES,
                            deletes,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> DeleteOperationsBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        DeleteOperationsBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<DeleteOperations<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for DeleteOperations<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("DeleteOperations");
                        ds.field("deletes", &self.deletes());
                        ds.finish()
                    }
                }
                pub enum EntryOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Entry<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Entry<'a> {
                    type Inner = Entry<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Entry<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Entry { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args EntryArgs,
                    ) -> flatbuffers::WIPOffset<Entry<'bldr>> {
                        let mut builder = EntryBuilder::new(_fbb);
                        if let Some(x) = args.operation {
                            builder.add_operation(x);
                        }
                        builder.add_operation_type(args.operation_type);
                        builder.finish()
                    }

                    pub const VT_OPERATION_TYPE: flatbuffers::VOffsetT = 4;
                    pub const VT_OPERATION: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn operation_type(&self) -> Operation {
                        self._tab
                            .get::<Operation>(Entry::VT_OPERATION_TYPE, Some(Operation::NONE))
                            .unwrap()
                    }
                    #[inline]
                    pub fn operation(&self) -> Option<flatbuffers::Table<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                Entry::VT_OPERATION,
                                None,
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn operation_as_write(&self) -> Option<WriteOperations<'a>> {
                        if self.operation_type() == Operation::write {
                            self.operation().map(WriteOperations::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn operation_as_delete(&self) -> Option<DeleteOperations<'a>> {
                        if self.operation_type() == Operation::delete {
                            self.operation().map(DeleteOperations::init_from_table)
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for Entry<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_union::<Operation, _>(&"operation_type", Self::VT_OPERATION_TYPE, &"operation", Self::VT_OPERATION, false, |key, v, pos| {
        match key {
          Operation::write => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WriteOperations>>("Operation::write", pos),
          Operation::delete => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DeleteOperations>>("Operation::delete", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                        Ok(())
                    }
                }
                pub struct EntryArgs {
                    pub operation_type: Operation,
                    pub operation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                }
                impl<'a> Default for EntryArgs {
                    #[inline]
                    fn default() -> Self {
                        EntryArgs {
                            operation_type: Operation::NONE,
                            operation: None,
                        }
                    }
                }
                pub struct EntryBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> EntryBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_operation_type(&mut self, operation_type: Operation) {
                        self.fbb_.push_slot::<Operation>(
                            Entry::VT_OPERATION_TYPE,
                            operation_type,
                            Operation::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_operation(
                        &mut self,
                        operation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Entry::VT_OPERATION,
                            operation,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> EntryBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        EntryBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Entry<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Entry<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Entry");
                        ds.field("operation_type", &self.operation_type());
                        match self.operation_type() {
                            Operation::write => {
                                if let Some(x) = self.operation_as_write() {
                                    ds.field("operation", &x)
                                } else {
                                    ds.field("operation", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            Operation::delete => {
                                if let Some(x) = self.operation_as_delete() {
                                    ds.field("operation", &x)
                                } else {
                                    ds.field("operation", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("operation", &x)
                            }
                        };
                        ds.finish()
                    }
                }
                pub enum PartitionWriteOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct PartitionWrite<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for PartitionWrite<'a> {
                    type Inner = PartitionWrite<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> PartitionWrite<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        PartitionWrite { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args PartitionWriteArgs<'args>,
                    ) -> flatbuffers::WIPOffset<PartitionWrite<'bldr>> {
                        let mut builder = PartitionWriteBuilder::new(_fbb);
                        if let Some(x) = args.table_batches {
                            builder.add_table_batches(x);
                        }
                        if let Some(x) = args.key {
                            builder.add_key(x);
                        }
                        builder.finish()
                    }

                    pub const VT_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_TABLE_BATCHES: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn key(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(PartitionWrite::VT_KEY, None)
                    }
                    #[inline]
                    pub fn table_batches(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch>>,
                        >>(PartitionWrite::VT_TABLE_BATCHES, None)
                    }
                }

                impl flatbuffers::Verifiable for PartitionWrite<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"key",
                                Self::VT_KEY,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<
                                    '_,
                                    flatbuffers::ForwardsUOffset<TableWriteBatch>,
                                >,
                            >>(
                                &"table_batches", Self::VT_TABLE_BATCHES, false
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct PartitionWriteArgs<'a> {
                    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub table_batches: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>,
                            >,
                        >,
                    >,
                }
                impl<'a> Default for PartitionWriteArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        PartitionWriteArgs {
                            key: None,
                            table_batches: None,
                        }
                    }
                }
                pub struct PartitionWriteBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> PartitionWriteBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PartitionWrite::VT_KEY,
                            key,
                        );
                    }
                    #[inline]
                    pub fn add_table_batches(
                        &mut self,
                        table_batches: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<TableWriteBatch<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PartitionWrite::VT_TABLE_BATCHES,
                            table_batches,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> PartitionWriteBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        PartitionWriteBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<PartitionWrite<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for PartitionWrite<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("PartitionWrite");
                        ds.field("key", &self.key());
                        ds.field("table_batches", &self.table_batches());
                        ds.finish()
                    }
                }
                pub enum DeleteOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Delete<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Delete<'a> {
                    type Inner = Delete<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Delete<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Delete { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args DeleteArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Delete<'bldr>> {
                        let mut builder = DeleteBuilder::new(_fbb);
                        if let Some(x) = args.predicate {
                            builder.add_predicate(x);
                        }
                        if let Some(x) = args.table_name {
                            builder.add_table_name(x);
                        }
                        builder.finish()
                    }

                    pub const VT_TABLE_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_PREDICATE: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn table_name(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(Delete::VT_TABLE_NAME, None)
                    }
                    #[inline]
                    pub fn predicate(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(Delete::VT_PREDICATE, None)
                    }
                }

                impl flatbuffers::Verifiable for Delete<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"table_name",
                                Self::VT_TABLE_NAME,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"predicate",
                                Self::VT_PREDICATE,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct DeleteArgs<'a> {
                    pub table_name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub predicate: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for DeleteArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        DeleteArgs {
                            table_name: None,
                            predicate: None,
                        }
                    }
                }
                pub struct DeleteBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> DeleteBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_table_name(&mut self, table_name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Delete::VT_TABLE_NAME,
                            table_name,
                        );
                    }
                    #[inline]
                    pub fn add_predicate(&mut self, predicate: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Delete::VT_PREDICATE,
                            predicate,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> DeleteBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        DeleteBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Delete<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Delete<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Delete");
                        ds.field("table_name", &self.table_name());
                        ds.field("predicate", &self.predicate());
                        ds.finish()
                    }
                }
                pub enum TableWriteBatchOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct TableWriteBatch<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TableWriteBatch<'a> {
                    type Inner = TableWriteBatch<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> TableWriteBatch<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TableWriteBatch { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args TableWriteBatchArgs<'args>,
                    ) -> flatbuffers::WIPOffset<TableWriteBatch<'bldr>> {
                        let mut builder = TableWriteBatchBuilder::new(_fbb);
                        if let Some(x) = args.columns {
                            builder.add_columns(x);
                        }
                        if let Some(x) = args.name {
                            builder.add_name(x);
                        }
                        builder.finish()
                    }

                    pub const VT_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_COLUMNS: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn name(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            TableWriteBatch::VT_NAME,
                            None,
                        )
                    }
                    #[inline]
                    pub fn columns(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
                        >>(TableWriteBatch::VT_COLUMNS, None)
                    }
                }

                impl flatbuffers::Verifiable for TableWriteBatch<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"name",
                                Self::VT_NAME,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
                            >>(&"columns", Self::VT_COLUMNS, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct TableWriteBatchArgs<'a> {
                    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub columns: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for TableWriteBatchArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        TableWriteBatchArgs {
                            name: None,
                            columns: None,
                        }
                    }
                }
                pub struct TableWriteBatchBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> TableWriteBatchBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TableWriteBatch::VT_NAME,
                            name,
                        );
                    }
                    #[inline]
                    pub fn add_columns(
                        &mut self,
                        columns: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TableWriteBatch::VT_COLUMNS,
                            columns,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> TableWriteBatchBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        TableWriteBatchBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TableWriteBatch<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for TableWriteBatch<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("TableWriteBatch");
                        ds.field("name", &self.name());
                        ds.field("columns", &self.columns());
                        ds.finish()
                    }
                }
                pub enum ColumnOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Column<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Column<'a> {
                    type Inner = Column<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Column<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Column { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args ColumnArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Column<'bldr>> {
                        let mut builder = ColumnBuilder::new(_fbb);
                        if let Some(x) = args.null_mask {
                            builder.add_null_mask(x);
                        }
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        if let Some(x) = args.name {
                            builder.add_name(x);
                        }
                        builder.add_values_type(args.values_type);
                        builder.add_logical_column_type(args.logical_column_type);
                        builder.finish()
                    }

                    pub const VT_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_LOGICAL_COLUMN_TYPE: flatbuffers::VOffsetT = 6;
                    pub const VT_VALUES_TYPE: flatbuffers::VOffsetT = 8;
                    pub const VT_VALUES: flatbuffers::VOffsetT = 10;
                    pub const VT_NULL_MASK: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub fn name(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(Column::VT_NAME, None)
                    }
                    #[inline]
                    pub fn logical_column_type(&self) -> LogicalColumnType {
                        self._tab
                            .get::<LogicalColumnType>(
                                Column::VT_LOGICAL_COLUMN_TYPE,
                                Some(LogicalColumnType::IOx),
                            )
                            .unwrap()
                    }
                    #[inline]
                    pub fn values_type(&self) -> ColumnValues {
                        self._tab
                            .get::<ColumnValues>(Column::VT_VALUES_TYPE, Some(ColumnValues::NONE))
                            .unwrap()
                    }
                    #[inline]
                    pub fn values(&self) -> Option<flatbuffers::Table<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                Column::VT_VALUES,
                                None,
                            )
                    }
                    #[inline]
                    pub fn null_mask(&self) -> Option<&'a [u8]> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                Column::VT_NULL_MASK,
                                None,
                            )
                            .map(|v| v.safe_slice())
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_i64values(&self) -> Option<I64Values<'a>> {
                        if self.values_type() == ColumnValues::I64Values {
                            self.values().map(I64Values::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_f64values(&self) -> Option<F64Values<'a>> {
                        if self.values_type() == ColumnValues::F64Values {
                            self.values().map(F64Values::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_u64values(&self) -> Option<U64Values<'a>> {
                        if self.values_type() == ColumnValues::U64Values {
                            self.values().map(U64Values::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_string_values(&self) -> Option<StringValues<'a>> {
                        if self.values_type() == ColumnValues::StringValues {
                            self.values().map(StringValues::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_bool_values(&self) -> Option<BoolValues<'a>> {
                        if self.values_type() == ColumnValues::BoolValues {
                            self.values().map(BoolValues::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn values_as_bytes_values(&self) -> Option<BytesValues<'a>> {
                        if self.values_type() == ColumnValues::BytesValues {
                            self.values().map(BytesValues::init_from_table)
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for Column<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<LogicalColumnType>(&"logical_column_type", Self::VT_LOGICAL_COLUMN_TYPE, false)?
     .visit_union::<ColumnValues, _>(&"values_type", Self::VT_VALUES_TYPE, &"values", Self::VT_VALUES, false, |key, v, pos| {
        match key {
          ColumnValues::I64Values => v.verify_union_variant::<flatbuffers::ForwardsUOffset<I64Values>>("ColumnValues::I64Values", pos),
          ColumnValues::F64Values => v.verify_union_variant::<flatbuffers::ForwardsUOffset<F64Values>>("ColumnValues::F64Values", pos),
          ColumnValues::U64Values => v.verify_union_variant::<flatbuffers::ForwardsUOffset<U64Values>>("ColumnValues::U64Values", pos),
          ColumnValues::StringValues => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringValues>>("ColumnValues::StringValues", pos),
          ColumnValues::BoolValues => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoolValues>>("ColumnValues::BoolValues", pos),
          ColumnValues::BytesValues => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BytesValues>>("ColumnValues::BytesValues", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"null_mask", Self::VT_NULL_MASK, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct ColumnArgs<'a> {
                    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub logical_column_type: LogicalColumnType,
                    pub values_type: ColumnValues,
                    pub values: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                    pub null_mask: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                }
                impl<'a> Default for ColumnArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ColumnArgs {
                            name: None,
                            logical_column_type: LogicalColumnType::IOx,
                            values_type: ColumnValues::NONE,
                            values: None,
                            null_mask: None,
                        }
                    }
                }
                pub struct ColumnBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> ColumnBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<_>>(Column::VT_NAME, name);
                    }
                    #[inline]
                    pub fn add_logical_column_type(
                        &mut self,
                        logical_column_type: LogicalColumnType,
                    ) {
                        self.fbb_.push_slot::<LogicalColumnType>(
                            Column::VT_LOGICAL_COLUMN_TYPE,
                            logical_column_type,
                            LogicalColumnType::IOx,
                        );
                    }
                    #[inline]
                    pub fn add_values_type(&mut self, values_type: ColumnValues) {
                        self.fbb_.push_slot::<ColumnValues>(
                            Column::VT_VALUES_TYPE,
                            values_type,
                            ColumnValues::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Column::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn add_null_mask(
                        &mut self,
                        null_mask: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Column::VT_NULL_MASK,
                            null_mask,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> ColumnBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        ColumnBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Column<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Column");
                        ds.field("name", &self.name());
                        ds.field("logical_column_type", &self.logical_column_type());
                        ds.field("values_type", &self.values_type());
                        match self.values_type() {
                            ColumnValues::I64Values => {
                                if let Some(x) = self.values_as_i64values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValues::F64Values => {
                                if let Some(x) = self.values_as_f64values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValues::U64Values => {
                                if let Some(x) = self.values_as_u64values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValues::StringValues => {
                                if let Some(x) = self.values_as_string_values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValues::BoolValues => {
                                if let Some(x) = self.values_as_bool_values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValues::BytesValues => {
                                if let Some(x) = self.values_as_bytes_values() {
                                    ds.field("values", &x)
                                } else {
                                    ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("values", &x)
                            }
                        };
                        ds.field("null_mask", &self.null_mask());
                        ds.finish()
                    }
                }
                pub enum I64ValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct I64Values<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for I64Values<'a> {
                    type Inner = I64Values<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> I64Values<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        I64Values { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args I64ValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<I64Values<'bldr>> {
                        let mut builder = I64ValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(&self) -> Option<flatbuffers::Vector<'a, i64>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                                I64Values::VT_VALUES,
                                None,
                            )
                    }
                }

                impl flatbuffers::Verifiable for I64Values<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"values", Self::VT_VALUES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct I64ValuesArgs<'a> {
                    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
                }
                impl<'a> Default for I64ValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        I64ValuesArgs { values: None }
                    }
                }
                pub struct I64ValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> I64ValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            I64Values::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> I64ValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        I64ValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<I64Values<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for I64Values<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("I64Values");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum F64ValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct F64Values<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for F64Values<'a> {
                    type Inner = F64Values<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> F64Values<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        F64Values { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args F64ValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<F64Values<'bldr>> {
                        let mut builder = F64ValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(&self) -> Option<flatbuffers::Vector<'a, f64>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                                F64Values::VT_VALUES,
                                None,
                            )
                    }
                }

                impl flatbuffers::Verifiable for F64Values<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"values", Self::VT_VALUES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct F64ValuesArgs<'a> {
                    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
                }
                impl<'a> Default for F64ValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        F64ValuesArgs { values: None }
                    }
                }
                pub struct F64ValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> F64ValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            F64Values::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> F64ValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        F64ValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<F64Values<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for F64Values<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("F64Values");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum U64ValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct U64Values<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for U64Values<'a> {
                    type Inner = U64Values<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> U64Values<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        U64Values { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args U64ValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<U64Values<'bldr>> {
                        let mut builder = U64ValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                                U64Values::VT_VALUES,
                                None,
                            )
                    }
                }

                impl flatbuffers::Verifiable for U64Values<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"values", Self::VT_VALUES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct U64ValuesArgs<'a> {
                    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
                }
                impl<'a> Default for U64ValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        U64ValuesArgs { values: None }
                    }
                }
                pub struct U64ValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> U64ValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            U64Values::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> U64ValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        U64ValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<U64Values<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for U64Values<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("U64Values");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum StringValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct StringValues<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for StringValues<'a> {
                    type Inner = StringValues<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> StringValues<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        StringValues { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args StringValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<StringValues<'bldr>> {
                        let mut builder = StringValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                        >>(StringValues::VT_VALUES, None)
                    }
                }

                impl flatbuffers::Verifiable for StringValues<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                            >>(&"values", Self::VT_VALUES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct StringValuesArgs<'a> {
                    pub values: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                        >,
                    >,
                }
                impl<'a> Default for StringValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        StringValuesArgs { values: None }
                    }
                }
                pub struct StringValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> StringValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StringValues::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> StringValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        StringValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<StringValues<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for StringValues<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("StringValues");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum BoolValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct BoolValues<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for BoolValues<'a> {
                    type Inner = BoolValues<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> BoolValues<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        BoolValues { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args BoolValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<BoolValues<'bldr>> {
                        let mut builder = BoolValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(&self) -> Option<&'a [bool]> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(
                                BoolValues::VT_VALUES,
                                None,
                            )
                            .map(|v| v.safe_slice())
                    }
                }

                impl flatbuffers::Verifiable for BoolValues<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"values", Self::VT_VALUES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct BoolValuesArgs<'a> {
                    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
                }
                impl<'a> Default for BoolValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        BoolValuesArgs { values: None }
                    }
                }
                pub struct BoolValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> BoolValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, bool>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            BoolValues::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> BoolValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        BoolValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<BoolValues<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for BoolValues<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("BoolValues");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum BytesValuesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct BytesValues<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for BytesValues<'a> {
                    type Inner = BytesValues<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> BytesValues<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        BytesValues { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args BytesValuesArgs<'args>,
                    ) -> flatbuffers::WIPOffset<BytesValues<'bldr>> {
                        let mut builder = BytesValuesBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue>>,
                        >>(BytesValues::VT_VALUES, None)
                    }
                }

                impl flatbuffers::Verifiable for BytesValues<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BytesValue>>,
                            >>(&"values", Self::VT_VALUES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct BytesValuesArgs<'a> {
                    pub values: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BytesValue<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for BytesValuesArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        BytesValuesArgs { values: None }
                    }
                }
                pub struct BytesValuesBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> BytesValuesBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BytesValue<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            BytesValues::VT_VALUES,
                            values,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> BytesValuesBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        BytesValuesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<BytesValues<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for BytesValues<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("BytesValues");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum BytesValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct BytesValue<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for BytesValue<'a> {
                    type Inner = BytesValue<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> BytesValue<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        BytesValue { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args BytesValueArgs<'args>,
                    ) -> flatbuffers::WIPOffset<BytesValue<'bldr>> {
                        let mut builder = BytesValueBuilder::new(_fbb);
                        if let Some(x) = args.data {
                            builder.add_data(x);
                        }
                        builder.finish()
                    }

                    pub const VT_DATA: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn data(&self) -> Option<&'a [u8]> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                BytesValue::VT_DATA,
                                None,
                            )
                            .map(|v| v.safe_slice())
                    }
                }

                impl flatbuffers::Verifiable for BytesValue<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"data", Self::VT_DATA, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct BytesValueArgs<'a> {
                    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                }
                impl<'a> Default for BytesValueArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        BytesValueArgs { data: None }
                    }
                }
                pub struct BytesValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> BytesValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_data(
                        &mut self,
                        data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            BytesValue::VT_DATA,
                            data,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> BytesValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        BytesValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<BytesValue<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for BytesValue<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("BytesValue");
                        ds.field("data", &self.data());
                        ds.finish()
                    }
                }
            } // pub mod v1
        } // pub mod write
    } // pub mod iox
} // pub mod influxdata
