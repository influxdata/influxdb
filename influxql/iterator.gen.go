// Generated by tmpl
// https://github.com/benbjohnson/tmpl

package influxql

import (
	"container/heap"
	"math"
	"sort"
	"sync"
)

// FloatIterator represents a stream of float points.
type FloatIterator interface {
	Iterator
	Next() *FloatPoint
}

// FloatIterators represents a list of float iterators.
type FloatIterators []FloatIterator

// Close closes all iterators.
func (a FloatIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// newFloatIterators converts a slice of Iterator to a slice of FloatIterator.
// Panic if any iterator in itrs is not a FloatIterator.
func newFloatIterators(itrs []Iterator) []FloatIterator {
	a := make([]FloatIterator, len(itrs))
	for i, itr := range itrs {
		a[i] = itr.(FloatIterator)
	}
	return a
}

// bufFloatIterator represents a buffered FloatIterator.
type bufFloatIterator struct {
	itr FloatIterator
	buf *FloatPoint
}

// newBufFloatIterator returns a buffered FloatIterator.
func newBufFloatIterator(itr FloatIterator) *bufFloatIterator {
	return &bufFloatIterator{
		itr: itr,
	}
}

// Close closes the underlying iterator.
func (itr *bufFloatIterator) Close() error { return itr.itr.Close() }

// PeekTime returns the time of the next point.
// Returns zero time if no more points available.
func (itr *bufFloatIterator) PeekTime() int64 {
	v := itr.Next()
	if v == nil {
		return ZeroTime
	}

	t := v.Time
	itr.unread(v)
	return t
}

// Next returns the current buffer, if exists, or calls the underlying iterator.
func (itr *bufFloatIterator) Next() *FloatPoint {
	if itr.buf != nil {
		buf := itr.buf
		itr.buf = nil
		return buf
	}
	return itr.itr.Next()
}

// NextInWindow returns the next value if it is between [startTime, endTime).
// If the next value is outside the range then it is moved to the buffer.
func (itr *bufFloatIterator) NextInWindow(startTime, endTime int64) *FloatPoint {
	v := itr.Next()
	if v == nil {
		return nil
	} else if v.Time < startTime || v.Time >= endTime {
		itr.unread(v)
		return nil
	}
	return v
}

// unread sets v to the buffer. It is read on the next call to Next().
func (itr *bufFloatIterator) unread(v *FloatPoint) { itr.buf = v }

// bufFloatIterators represents a list of buffered FloatIterator.
type bufFloatIterators []*bufFloatIterator

// newBufFloatIterators returns a list of buffered FloatIterators.
func newBufFloatIterators(itrs []FloatIterator) bufFloatIterators {
	a := make(bufFloatIterators, len(itrs))
	for i := range itrs {
		a[i] = newBufFloatIterator(itrs[i])
	}
	return a
}

// Close closes all iterators.
func (a bufFloatIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// window calculates the next window based on sorted name & tags name and time window.
func (a bufFloatIterators) window(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	if opt.Ascending {
		return a.windowAsc(opt)
	}
	return a.windowDesc(opt)
}

func (a bufFloatIterators) windowAsc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is lower (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name < name || (p.Name == name && p.Tags.ID() < tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time < min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

func (a bufFloatIterators) windowDesc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is higher (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name > name || (p.Name == name && p.Tags.ID() > tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time > min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

// floatMergeIterator represents an iterator that combines multiple float iterators.
type floatMergeIterator struct {
	inputs bufFloatIterators
	opt    IteratorOptions
}

// newFloatMergeIterator returns a new instance of floatMergeIterator.
func newFloatMergeIterator(inputs []FloatIterator, opt IteratorOptions) *floatMergeIterator {
	return &floatMergeIterator{
		inputs: newBufFloatIterators(inputs),
		opt:    opt,
	}
}

// Close closes the underlying iterators.
func (itr *floatMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next point from the iterator.
func (itr *floatMergeIterator) Next() *FloatPoint {
	// OPTIMIZE(benbjohnson): Buffer multiple points for a single window.

	// Determine the window for the next lowest name+tags.
	name, tags, startTime, endTime := itr.inputs.window(itr.opt)
	for _, input := range itr.inputs {
		v := input.Next()
		if v == nil {
			continue
		} else if v.Name != name || !v.Tags.Equals(&tags) {
			if (itr.opt.Ascending && v.Time >= endTime) || (!itr.opt.Ascending && v.Time <= startTime) {
				input.unread(v)
				continue
			}
		}
		return v
	}
	return nil
}

// newFloatSortedMergeIterator returns an instance of floatSortedMergeIterator.
func newFloatSortedMergeIterator(inputs []FloatIterator, opt IteratorOptions) Iterator {
	itr := &floatSortedMergeIterator{
		inputs: newBufFloatIterators(inputs),
		heap:   make(floatHeap, 0, len(inputs)),
		opt:    opt,
	}

	// Initialize heap.
	for _, input := range inputs {
		// Read next point.
		p := input.Next()
		if p == nil {
			continue
		}

		// Append to the heap.
		itr.heap = append(itr.heap, &floatHeapItem{point: p, itr: input, ascending: opt.Ascending})
	}
	heap.Init(&itr.heap)

	return itr
}

// floatSortedMergeIterator is an iterator that sorts and merges multiple iterators into one.
type floatSortedMergeIterator struct {
	inputs bufFloatIterators
	opt    IteratorOptions
	heap   floatHeap
}

// Close closes the underlying iterators.
func (itr *floatSortedMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next points from the iterator.
func (itr *floatSortedMergeIterator) Next() *FloatPoint { return itr.pop() }

// pop returns the next point from the heap.
// Reads the next point from item's cursor and puts it back on the heap.
func (itr *floatSortedMergeIterator) pop() *FloatPoint {
	if len(itr.heap) == 0 {
		return nil
	}

	// Read the next item from the heap.
	item := heap.Pop(&itr.heap).(*floatHeapItem)

	// Copy the point for return.
	p := item.point.Clone()

	// Read the next item from the cursor. Push back to heap if one exists.
	if item.point = item.itr.Next(); item.point != nil {
		heap.Push(&itr.heap, item)
	}

	return p
}

// floatHeap represents a heap of floatHeapItems.
type floatHeap []*floatHeapItem

func (h floatHeap) Len() int      { return len(h) }
func (h floatHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
func (h floatHeap) Less(i, j int) bool {
	x, y := h[i].point, h[j].point

	if h[i].ascending {
		if x.Name != y.Name {
			return x.Name < y.Name
		} else if !x.Tags.Equals(&y.Tags) {
			return x.Tags.ID() < y.Tags.ID()
		}
		return x.Time < y.Time
	}

	if x.Name != y.Name {
		return x.Name > y.Name
	} else if !x.Tags.Equals(&y.Tags) {
		return x.Tags.ID() > y.Tags.ID()
	}
	return x.Time > y.Time
}

func (h *floatHeap) Push(x interface{}) {
	*h = append(*h, x.(*floatHeapItem))
}

func (h *floatHeap) Pop() interface{} {
	old := *h
	n := len(old)
	item := old[n-1]
	*h = old[0 : n-1]
	return item
}

type floatHeapItem struct {
	point     *FloatPoint
	itr       FloatIterator
	ascending bool
}

// floatLimitIterator represents an iterator that limits points per group.
type floatLimitIterator struct {
	input FloatIterator
	opt   IteratorOptions
	n     int

	prev struct {
		name string
		tags Tags
	}
}

// newFloatLimitIterator returns a new instance of floatLimitIterator.
func newFloatLimitIterator(input FloatIterator, opt IteratorOptions) *floatLimitIterator {
	return &floatLimitIterator{
		input: input,
		opt:   opt,
	}
}

// Close closes the underlying iterators.
func (itr *floatLimitIterator) Close() error { return itr.input.Close() }

// Next returns the next point from the iterator.
func (itr *floatLimitIterator) Next() *FloatPoint {
	for {
		p := itr.input.Next()
		if p == nil {
			return nil
		}

		// Reset window and counter if a new window is encountered.
		if p.Name != itr.prev.name || !p.Tags.Equals(&itr.prev.tags) {
			itr.prev.name = p.Name
			itr.prev.tags = p.Tags
			itr.n = 0
		}

		// Increment counter.
		itr.n++

		// Read next point if not beyond the offset.
		if itr.n <= itr.opt.Offset {
			continue
		}

		// Read next point if we're beyond the limit.
		if itr.opt.Limit > 0 && (itr.n-itr.opt.Offset) > itr.opt.Limit {
			continue
		}

		return p
	}
}

// floatJoinIterator represents a join iterator that processes float values.
type floatJoinIterator struct {
	input FloatIterator
	buf   *FloatPoint      // next value from input
	c     chan *FloatPoint // streaming output channel
	once  sync.Once
}

// newFloatJoinIterator returns a new join iterator that wraps input.
func newFloatJoinIterator(input FloatIterator) *floatJoinIterator {
	return &floatJoinIterator{
		input: input,
		c:     make(chan *FloatPoint, 1),
	}
}

// Close close the iterator.
func (itr *floatJoinIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

// Next returns the next point from the streaming channel.
func (itr *floatJoinIterator) Next() *FloatPoint { return <-itr.c }

// loadBuf reads the next value from the input into the buffer.
func (itr *floatJoinIterator) loadBuf() (t int64, name string, tags Tags) {
	if itr.buf != nil {
		return itr.buf.Time, itr.buf.Name, itr.buf.Tags
	}

	itr.buf = itr.input.Next()
	if itr.buf == nil {
		return ZeroTime, "", Tags{}
	}
	return itr.buf.Time, itr.buf.Name, itr.buf.Tags
}

// emitAt emits the buffered point if its timestamp equals t.
// Otherwise it emits a null value with the timestamp t.
func (itr *floatJoinIterator) emitAt(t int64, name string, tags Tags) {
	var v *FloatPoint
	if itr.buf == nil || itr.buf.Time != t || itr.buf.Name != name || !itr.buf.Tags.Equals(&tags) {
		v = &FloatPoint{Name: name, Tags: tags, Time: t, Value: math.NaN()}
	} else {
		v, itr.buf = itr.buf, nil
	}
	itr.c <- v
}

// floatAuxIterator represents a float implementation of AuxIterator.
type floatAuxIterator struct {
	input  *bufFloatIterator
	output chan *FloatPoint
	fields auxIteratorFields
}

func newFloatAuxIterator(input FloatIterator, opt IteratorOptions) *floatAuxIterator {
	itr := &floatAuxIterator{
		input:  newBufFloatIterator(input),
		output: make(chan *FloatPoint, 1),
		fields: newAuxIteratorFields(opt),
	}

	// Initialize auxilary fields.
	if p := itr.input.Next(); p != nil {
		itr.output <- p
		itr.fields.init(p)
	}

	go itr.stream()
	return itr
}

func (itr *floatAuxIterator) Close() error                  { return itr.input.Close() }
func (itr *floatAuxIterator) Next() *FloatPoint             { return <-itr.output }
func (itr *floatAuxIterator) Iterator(name string) Iterator { return itr.fields.iterator(name) }

func (itr *floatAuxIterator) stream() {
	for {
		// Read next point.
		p := itr.input.Next()
		if p == nil {
			break
		}

		// Send point to output and to each field iterator.
		itr.output <- p
		itr.fields.send(p)
	}

	close(itr.output)
	itr.fields.close()
}

// floatChanIterator represents a new instance of floatChanIterator.
type floatChanIterator struct {
	c    chan *FloatPoint
	once sync.Once
}

func (itr *floatChanIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

func (itr *floatChanIterator) Next() *FloatPoint { return <-itr.c }

// floatReduceIterator executes a reducer for every interval and buffers the result.
type floatReduceIterator struct {
	input  *bufFloatIterator
	fn     floatReduceFunc
	opt    IteratorOptions
	points []*FloatPoint
}

// Close closes the iterator and all child iterators.
func (itr *floatReduceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *floatReduceIterator) Next() *FloatPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *floatReduceIterator) reduce() []*FloatPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Create points by tags.
	m := make(map[string]*FloatPoint)
	for {
		// Read next point.
		curr := itr.input.NextInWindow(startTime, endTime)
		if curr == nil {
			break
		}
		tags := curr.Tags.Subset(itr.opt.Dimensions)

		// Pass previous and current points to reducer.
		prev := m[tags.ID()]
		t, v, aux := itr.fn(prev, curr, &reduceOptions)
		if t == ZeroTime {
			continue
		}

		// If previous value didn't exist, create it and copy values.
		if prev == nil {
			prev = &FloatPoint{Name: curr.Name, Tags: tags}
			m[tags.ID()] = prev
		}
		prev.Time = t
		prev.Value = v
		prev.Aux = aux
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	a := make([]*FloatPoint, len(m))
	for i, k := range keys {
		a[i] = m[k]
	}

	return a
}

// floatReduceFunc is the function called by a FloatPoint reducer.
type floatReduceFunc func(prev, curr *FloatPoint, opt *reduceOptions) (t int64, v float64, aux []interface{})

// floatReduceSliceIterator executes a reducer on all points in a window and buffers the result.
type floatReduceSliceIterator struct {
	input  *bufFloatIterator
	fn     floatReduceSliceFunc
	opt    IteratorOptions
	points []FloatPoint
}

// Close closes the iterator and all child iterators.
func (itr *floatReduceSliceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *floatReduceSliceIterator) Next() *FloatPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return &p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *floatReduceSliceIterator) reduce() []FloatPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Group points by name and tagset.
	groups := make(map[string]struct {
		name   string
		tags   Tags
		points []FloatPoint
	})
	for {
		// Read next point.
		p := itr.input.NextInWindow(startTime, endTime)
		if p == nil {
			break
		}
		tags := p.Tags.Subset(itr.opt.Dimensions)

		// Append point to dimension.
		id := tags.ID()
		g := groups[id]
		g.name = p.Name
		g.tags = tags
		g.points = append(g.points, *p)
		groups[id] = g
	}

	// Reduce each set into a set of values.
	results := make(map[string][]FloatPoint)
	for key, g := range groups {
		a := itr.fn(g.points, &reduceOptions)
		if len(a) == 0 {
			continue
		}

		// Update name and tags for each returned point.
		for i := range a {
			a[i].Name = g.name
			a[i].Tags = g.tags
		}
		results[key] = a
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(results))
	for k := range results {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	// Reverse order points within each key.
	a := make([]FloatPoint, 0, len(results))
	for _, k := range keys {
		for i := len(results[k]) - 1; i >= 0; i-- {
			a = append(a, results[k][i])
		}
	}

	return a
}

// floatReduceSliceFunc is the function called by a FloatPoint slice reducer.
type floatReduceSliceFunc func(a []FloatPoint, opt *reduceOptions) []FloatPoint

// StringIterator represents a stream of string points.
type StringIterator interface {
	Iterator
	Next() *StringPoint
}

// StringIterators represents a list of string iterators.
type StringIterators []StringIterator

// Close closes all iterators.
func (a StringIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// newStringIterators converts a slice of Iterator to a slice of StringIterator.
// Panic if any iterator in itrs is not a StringIterator.
func newStringIterators(itrs []Iterator) []StringIterator {
	a := make([]StringIterator, len(itrs))
	for i, itr := range itrs {
		a[i] = itr.(StringIterator)
	}
	return a
}

// bufStringIterator represents a buffered StringIterator.
type bufStringIterator struct {
	itr StringIterator
	buf *StringPoint
}

// newBufStringIterator returns a buffered StringIterator.
func newBufStringIterator(itr StringIterator) *bufStringIterator {
	return &bufStringIterator{
		itr: itr,
	}
}

// Close closes the underlying iterator.
func (itr *bufStringIterator) Close() error { return itr.itr.Close() }

// PeekTime returns the time of the next point.
// Returns zero time if no more points available.
func (itr *bufStringIterator) PeekTime() int64 {
	v := itr.Next()
	if v == nil {
		return ZeroTime
	}

	t := v.Time
	itr.unread(v)
	return t
}

// Next returns the current buffer, if exists, or calls the underlying iterator.
func (itr *bufStringIterator) Next() *StringPoint {
	if itr.buf != nil {
		buf := itr.buf
		itr.buf = nil
		return buf
	}
	return itr.itr.Next()
}

// NextInWindow returns the next value if it is between [startTime, endTime).
// If the next value is outside the range then it is moved to the buffer.
func (itr *bufStringIterator) NextInWindow(startTime, endTime int64) *StringPoint {
	v := itr.Next()
	if v == nil {
		return nil
	} else if v.Time < startTime || v.Time >= endTime {
		itr.unread(v)
		return nil
	}
	return v
}

// unread sets v to the buffer. It is read on the next call to Next().
func (itr *bufStringIterator) unread(v *StringPoint) { itr.buf = v }

// bufStringIterators represents a list of buffered StringIterator.
type bufStringIterators []*bufStringIterator

// newBufStringIterators returns a list of buffered StringIterators.
func newBufStringIterators(itrs []StringIterator) bufStringIterators {
	a := make(bufStringIterators, len(itrs))
	for i := range itrs {
		a[i] = newBufStringIterator(itrs[i])
	}
	return a
}

// Close closes all iterators.
func (a bufStringIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// window calculates the next window based on sorted name & tags name and time window.
func (a bufStringIterators) window(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	if opt.Ascending {
		return a.windowAsc(opt)
	}
	return a.windowDesc(opt)
}

func (a bufStringIterators) windowAsc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is lower (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name < name || (p.Name == name && p.Tags.ID() < tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time < min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

func (a bufStringIterators) windowDesc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is higher (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name > name || (p.Name == name && p.Tags.ID() > tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time > min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

// stringMergeIterator represents an iterator that combines multiple string iterators.
type stringMergeIterator struct {
	inputs bufStringIterators
	opt    IteratorOptions
}

// newStringMergeIterator returns a new instance of stringMergeIterator.
func newStringMergeIterator(inputs []StringIterator, opt IteratorOptions) *stringMergeIterator {
	return &stringMergeIterator{
		inputs: newBufStringIterators(inputs),
		opt:    opt,
	}
}

// Close closes the underlying iterators.
func (itr *stringMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next point from the iterator.
func (itr *stringMergeIterator) Next() *StringPoint {
	// OPTIMIZE(benbjohnson): Buffer multiple points for a single window.

	// Determine the window for the next lowest name+tags.
	name, tags, startTime, endTime := itr.inputs.window(itr.opt)
	for _, input := range itr.inputs {
		v := input.Next()
		if v == nil {
			continue
		} else if v.Name != name || !v.Tags.Equals(&tags) {
			if (itr.opt.Ascending && v.Time >= endTime) || (!itr.opt.Ascending && v.Time <= startTime) {
				input.unread(v)
				continue
			}
		}
		return v
	}
	return nil
}

// newStringSortedMergeIterator returns an instance of stringSortedMergeIterator.
func newStringSortedMergeIterator(inputs []StringIterator, opt IteratorOptions) Iterator {
	itr := &stringSortedMergeIterator{
		inputs: newBufStringIterators(inputs),
		heap:   make(stringHeap, 0, len(inputs)),
		opt:    opt,
	}

	// Initialize heap.
	for _, input := range inputs {
		// Read next point.
		p := input.Next()
		if p == nil {
			continue
		}

		// Append to the heap.
		itr.heap = append(itr.heap, &stringHeapItem{point: p, itr: input, ascending: opt.Ascending})
	}
	heap.Init(&itr.heap)

	return itr
}

// stringSortedMergeIterator is an iterator that sorts and merges multiple iterators into one.
type stringSortedMergeIterator struct {
	inputs bufStringIterators
	opt    IteratorOptions
	heap   stringHeap
}

// Close closes the underlying iterators.
func (itr *stringSortedMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next points from the iterator.
func (itr *stringSortedMergeIterator) Next() *StringPoint { return itr.pop() }

// pop returns the next point from the heap.
// Reads the next point from item's cursor and puts it back on the heap.
func (itr *stringSortedMergeIterator) pop() *StringPoint {
	if len(itr.heap) == 0 {
		return nil
	}

	// Read the next item from the heap.
	item := heap.Pop(&itr.heap).(*stringHeapItem)

	// Copy the point for return.
	p := item.point.Clone()

	// Read the next item from the cursor. Push back to heap if one exists.
	if item.point = item.itr.Next(); item.point != nil {
		heap.Push(&itr.heap, item)
	}

	return p
}

// stringHeap represents a heap of stringHeapItems.
type stringHeap []*stringHeapItem

func (h stringHeap) Len() int      { return len(h) }
func (h stringHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
func (h stringHeap) Less(i, j int) bool {
	x, y := h[i].point, h[j].point

	if h[i].ascending {
		if x.Name != y.Name {
			return x.Name < y.Name
		} else if !x.Tags.Equals(&y.Tags) {
			return x.Tags.ID() < y.Tags.ID()
		}
		return x.Time < y.Time
	}

	if x.Name != y.Name {
		return x.Name > y.Name
	} else if !x.Tags.Equals(&y.Tags) {
		return x.Tags.ID() > y.Tags.ID()
	}
	return x.Time > y.Time
}

func (h *stringHeap) Push(x interface{}) {
	*h = append(*h, x.(*stringHeapItem))
}

func (h *stringHeap) Pop() interface{} {
	old := *h
	n := len(old)
	item := old[n-1]
	*h = old[0 : n-1]
	return item
}

type stringHeapItem struct {
	point     *StringPoint
	itr       StringIterator
	ascending bool
}

// stringLimitIterator represents an iterator that limits points per group.
type stringLimitIterator struct {
	input StringIterator
	opt   IteratorOptions
	n     int

	prev struct {
		name string
		tags Tags
	}
}

// newStringLimitIterator returns a new instance of stringLimitIterator.
func newStringLimitIterator(input StringIterator, opt IteratorOptions) *stringLimitIterator {
	return &stringLimitIterator{
		input: input,
		opt:   opt,
	}
}

// Close closes the underlying iterators.
func (itr *stringLimitIterator) Close() error { return itr.input.Close() }

// Next returns the next point from the iterator.
func (itr *stringLimitIterator) Next() *StringPoint {
	for {
		p := itr.input.Next()
		if p == nil {
			return nil
		}

		// Reset window and counter if a new window is encountered.
		if p.Name != itr.prev.name || !p.Tags.Equals(&itr.prev.tags) {
			itr.prev.name = p.Name
			itr.prev.tags = p.Tags
			itr.n = 0
		}

		// Increment counter.
		itr.n++

		// Read next point if not beyond the offset.
		if itr.n <= itr.opt.Offset {
			continue
		}

		// Read next point if we're beyond the limit.
		if itr.opt.Limit > 0 && (itr.n-itr.opt.Offset) > itr.opt.Limit {
			continue
		}

		return p
	}
}

// stringJoinIterator represents a join iterator that processes string values.
type stringJoinIterator struct {
	input StringIterator
	buf   *StringPoint      // next value from input
	c     chan *StringPoint // streaming output channel
	once  sync.Once
}

// newStringJoinIterator returns a new join iterator that wraps input.
func newStringJoinIterator(input StringIterator) *stringJoinIterator {
	return &stringJoinIterator{
		input: input,
		c:     make(chan *StringPoint, 1),
	}
}

// Close close the iterator.
func (itr *stringJoinIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

// Next returns the next point from the streaming channel.
func (itr *stringJoinIterator) Next() *StringPoint { return <-itr.c }

// loadBuf reads the next value from the input into the buffer.
func (itr *stringJoinIterator) loadBuf() (t int64, name string, tags Tags) {
	if itr.buf != nil {
		return itr.buf.Time, itr.buf.Name, itr.buf.Tags
	}

	itr.buf = itr.input.Next()
	if itr.buf == nil {
		return ZeroTime, "", Tags{}
	}
	return itr.buf.Time, itr.buf.Name, itr.buf.Tags
}

// emitAt emits the buffered point if its timestamp equals t.
// Otherwise it emits a null value with the timestamp t.
func (itr *stringJoinIterator) emitAt(t int64, name string, tags Tags) {
	var v *StringPoint
	if itr.buf == nil || itr.buf.Time != t || itr.buf.Name != name || !itr.buf.Tags.Equals(&tags) {
		v = &StringPoint{Name: name, Tags: tags, Time: t, Value: ""}
	} else {
		v, itr.buf = itr.buf, nil
	}
	itr.c <- v
}

// stringAuxIterator represents a string implementation of AuxIterator.
type stringAuxIterator struct {
	input  *bufStringIterator
	output chan *StringPoint
	fields auxIteratorFields
}

func newStringAuxIterator(input StringIterator, opt IteratorOptions) *stringAuxIterator {
	itr := &stringAuxIterator{
		input:  newBufStringIterator(input),
		output: make(chan *StringPoint, 1),
		fields: newAuxIteratorFields(opt),
	}

	// Initialize auxilary fields.
	if p := itr.input.Next(); p != nil {
		itr.output <- p
		itr.fields.init(p)
	}

	go itr.stream()
	return itr
}

func (itr *stringAuxIterator) Close() error                  { return itr.input.Close() }
func (itr *stringAuxIterator) Next() *StringPoint            { return <-itr.output }
func (itr *stringAuxIterator) Iterator(name string) Iterator { return itr.fields.iterator(name) }

func (itr *stringAuxIterator) stream() {
	for {
		// Read next point.
		p := itr.input.Next()
		if p == nil {
			break
		}

		// Send point to output and to each field iterator.
		itr.output <- p
		itr.fields.send(p)
	}

	close(itr.output)
	itr.fields.close()
}

// stringChanIterator represents a new instance of stringChanIterator.
type stringChanIterator struct {
	c    chan *StringPoint
	once sync.Once
}

func (itr *stringChanIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

func (itr *stringChanIterator) Next() *StringPoint { return <-itr.c }

// stringReduceIterator executes a reducer for every interval and buffers the result.
type stringReduceIterator struct {
	input  *bufStringIterator
	fn     stringReduceFunc
	opt    IteratorOptions
	points []*StringPoint
}

// Close closes the iterator and all child iterators.
func (itr *stringReduceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *stringReduceIterator) Next() *StringPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *stringReduceIterator) reduce() []*StringPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Create points by tags.
	m := make(map[string]*StringPoint)
	for {
		// Read next point.
		curr := itr.input.NextInWindow(startTime, endTime)
		if curr == nil {
			break
		}
		tags := curr.Tags.Subset(itr.opt.Dimensions)

		// Pass previous and current points to reducer.
		prev := m[tags.ID()]
		t, v, aux := itr.fn(prev, curr, &reduceOptions)
		if t == ZeroTime {
			continue
		}

		// If previous value didn't exist, create it and copy values.
		if prev == nil {
			prev = &StringPoint{Name: curr.Name, Tags: tags}
			m[tags.ID()] = prev
		}
		prev.Time = t
		prev.Value = v
		prev.Aux = aux
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	a := make([]*StringPoint, len(m))
	for i, k := range keys {
		a[i] = m[k]
	}

	return a
}

// stringReduceFunc is the function called by a StringPoint reducer.
type stringReduceFunc func(prev, curr *StringPoint, opt *reduceOptions) (t int64, v string, aux []interface{})

// stringReduceSliceIterator executes a reducer on all points in a window and buffers the result.
type stringReduceSliceIterator struct {
	input  *bufStringIterator
	fn     stringReduceSliceFunc
	opt    IteratorOptions
	points []StringPoint
}

// Close closes the iterator and all child iterators.
func (itr *stringReduceSliceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *stringReduceSliceIterator) Next() *StringPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return &p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *stringReduceSliceIterator) reduce() []StringPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Group points by name and tagset.
	groups := make(map[string]struct {
		name   string
		tags   Tags
		points []StringPoint
	})
	for {
		// Read next point.
		p := itr.input.NextInWindow(startTime, endTime)
		if p == nil {
			break
		}
		tags := p.Tags.Subset(itr.opt.Dimensions)

		// Append point to dimension.
		id := tags.ID()
		g := groups[id]
		g.name = p.Name
		g.tags = tags
		g.points = append(g.points, *p)
		groups[id] = g
	}

	// Reduce each set into a set of values.
	results := make(map[string][]StringPoint)
	for key, g := range groups {
		a := itr.fn(g.points, &reduceOptions)
		if len(a) == 0 {
			continue
		}

		// Update name and tags for each returned point.
		for i := range a {
			a[i].Name = g.name
			a[i].Tags = g.tags
		}
		results[key] = a
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(results))
	for k := range results {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	// Reverse order points within each key.
	a := make([]StringPoint, 0, len(results))
	for _, k := range keys {
		for i := len(results[k]) - 1; i >= 0; i-- {
			a = append(a, results[k][i])
		}
	}

	return a
}

// stringReduceSliceFunc is the function called by a StringPoint slice reducer.
type stringReduceSliceFunc func(a []StringPoint, opt *reduceOptions) []StringPoint

// BooleanIterator represents a stream of boolean points.
type BooleanIterator interface {
	Iterator
	Next() *BooleanPoint
}

// BooleanIterators represents a list of boolean iterators.
type BooleanIterators []BooleanIterator

// Close closes all iterators.
func (a BooleanIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// newBooleanIterators converts a slice of Iterator to a slice of BooleanIterator.
// Panic if any iterator in itrs is not a BooleanIterator.
func newBooleanIterators(itrs []Iterator) []BooleanIterator {
	a := make([]BooleanIterator, len(itrs))
	for i, itr := range itrs {
		a[i] = itr.(BooleanIterator)
	}
	return a
}

// bufBooleanIterator represents a buffered BooleanIterator.
type bufBooleanIterator struct {
	itr BooleanIterator
	buf *BooleanPoint
}

// newBufBooleanIterator returns a buffered BooleanIterator.
func newBufBooleanIterator(itr BooleanIterator) *bufBooleanIterator {
	return &bufBooleanIterator{
		itr: itr,
	}
}

// Close closes the underlying iterator.
func (itr *bufBooleanIterator) Close() error { return itr.itr.Close() }

// PeekTime returns the time of the next point.
// Returns zero time if no more points available.
func (itr *bufBooleanIterator) PeekTime() int64 {
	v := itr.Next()
	if v == nil {
		return ZeroTime
	}

	t := v.Time
	itr.unread(v)
	return t
}

// Next returns the current buffer, if exists, or calls the underlying iterator.
func (itr *bufBooleanIterator) Next() *BooleanPoint {
	if itr.buf != nil {
		buf := itr.buf
		itr.buf = nil
		return buf
	}
	return itr.itr.Next()
}

// NextInWindow returns the next value if it is between [startTime, endTime).
// If the next value is outside the range then it is moved to the buffer.
func (itr *bufBooleanIterator) NextInWindow(startTime, endTime int64) *BooleanPoint {
	v := itr.Next()
	if v == nil {
		return nil
	} else if v.Time < startTime || v.Time >= endTime {
		itr.unread(v)
		return nil
	}
	return v
}

// unread sets v to the buffer. It is read on the next call to Next().
func (itr *bufBooleanIterator) unread(v *BooleanPoint) { itr.buf = v }

// bufBooleanIterators represents a list of buffered BooleanIterator.
type bufBooleanIterators []*bufBooleanIterator

// newBufBooleanIterators returns a list of buffered BooleanIterators.
func newBufBooleanIterators(itrs []BooleanIterator) bufBooleanIterators {
	a := make(bufBooleanIterators, len(itrs))
	for i := range itrs {
		a[i] = newBufBooleanIterator(itrs[i])
	}
	return a
}

// Close closes all iterators.
func (a bufBooleanIterators) Close() error {
	for _, itr := range a {
		itr.Close()
	}
	return nil
}

// window calculates the next window based on sorted name & tags name and time window.
func (a bufBooleanIterators) window(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	if opt.Ascending {
		return a.windowAsc(opt)
	}
	return a.windowDesc(opt)
}

func (a bufBooleanIterators) windowAsc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is lower (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name < name || (p.Name == name && p.Tags.ID() < tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time < min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

func (a bufBooleanIterators) windowDesc(opt IteratorOptions) (name string, tags Tags, startTime, endTime int64) {
	min := ZeroTime
	for _, itr := range a {
		// Read next point. Ignore if no more points available.
		p := itr.Next()
		if p == nil {
			continue
		}

		// Update values if point's window is higher (sorted by <name,tags,time>).
		if min == ZeroTime || p.Name > name || (p.Name == name && p.Tags.ID() > tags.ID()) || (p.Name == name && p.Tags.Equals(&tags) && p.Time > min) {
			name = p.Name
			tags = p.Tags
			min = p.Time
		}

		// Push point back onto buffer.
		itr.unread(p)
	}

	// Calculate time window based on lowest time.
	if min != ZeroTime {
		startTime, endTime = opt.Window(min)
	}

	return
}

// booleanMergeIterator represents an iterator that combines multiple boolean iterators.
type booleanMergeIterator struct {
	inputs bufBooleanIterators
	opt    IteratorOptions
}

// newBooleanMergeIterator returns a new instance of booleanMergeIterator.
func newBooleanMergeIterator(inputs []BooleanIterator, opt IteratorOptions) *booleanMergeIterator {
	return &booleanMergeIterator{
		inputs: newBufBooleanIterators(inputs),
		opt:    opt,
	}
}

// Close closes the underlying iterators.
func (itr *booleanMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next point from the iterator.
func (itr *booleanMergeIterator) Next() *BooleanPoint {
	// OPTIMIZE(benbjohnson): Buffer multiple points for a single window.

	// Determine the window for the next lowest name+tags.
	name, tags, startTime, endTime := itr.inputs.window(itr.opt)
	for _, input := range itr.inputs {
		v := input.Next()
		if v == nil {
			continue
		} else if v.Name != name || !v.Tags.Equals(&tags) {
			if (itr.opt.Ascending && v.Time >= endTime) || (!itr.opt.Ascending && v.Time <= startTime) {
				input.unread(v)
				continue
			}
		}
		return v
	}
	return nil
}

// newBooleanSortedMergeIterator returns an instance of booleanSortedMergeIterator.
func newBooleanSortedMergeIterator(inputs []BooleanIterator, opt IteratorOptions) Iterator {
	itr := &booleanSortedMergeIterator{
		inputs: newBufBooleanIterators(inputs),
		heap:   make(booleanHeap, 0, len(inputs)),
		opt:    opt,
	}

	// Initialize heap.
	for _, input := range inputs {
		// Read next point.
		p := input.Next()
		if p == nil {
			continue
		}

		// Append to the heap.
		itr.heap = append(itr.heap, &booleanHeapItem{point: p, itr: input, ascending: opt.Ascending})
	}
	heap.Init(&itr.heap)

	return itr
}

// booleanSortedMergeIterator is an iterator that sorts and merges multiple iterators into one.
type booleanSortedMergeIterator struct {
	inputs bufBooleanIterators
	opt    IteratorOptions
	heap   booleanHeap
}

// Close closes the underlying iterators.
func (itr *booleanSortedMergeIterator) Close() error { return itr.inputs.Close() }

// Next returns the next points from the iterator.
func (itr *booleanSortedMergeIterator) Next() *BooleanPoint { return itr.pop() }

// pop returns the next point from the heap.
// Reads the next point from item's cursor and puts it back on the heap.
func (itr *booleanSortedMergeIterator) pop() *BooleanPoint {
	if len(itr.heap) == 0 {
		return nil
	}

	// Read the next item from the heap.
	item := heap.Pop(&itr.heap).(*booleanHeapItem)

	// Copy the point for return.
	p := item.point.Clone()

	// Read the next item from the cursor. Push back to heap if one exists.
	if item.point = item.itr.Next(); item.point != nil {
		heap.Push(&itr.heap, item)
	}

	return p
}

// booleanHeap represents a heap of booleanHeapItems.
type booleanHeap []*booleanHeapItem

func (h booleanHeap) Len() int      { return len(h) }
func (h booleanHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
func (h booleanHeap) Less(i, j int) bool {
	x, y := h[i].point, h[j].point

	if h[i].ascending {
		if x.Name != y.Name {
			return x.Name < y.Name
		} else if !x.Tags.Equals(&y.Tags) {
			return x.Tags.ID() < y.Tags.ID()
		}
		return x.Time < y.Time
	}

	if x.Name != y.Name {
		return x.Name > y.Name
	} else if !x.Tags.Equals(&y.Tags) {
		return x.Tags.ID() > y.Tags.ID()
	}
	return x.Time > y.Time
}

func (h *booleanHeap) Push(x interface{}) {
	*h = append(*h, x.(*booleanHeapItem))
}

func (h *booleanHeap) Pop() interface{} {
	old := *h
	n := len(old)
	item := old[n-1]
	*h = old[0 : n-1]
	return item
}

type booleanHeapItem struct {
	point     *BooleanPoint
	itr       BooleanIterator
	ascending bool
}

// booleanLimitIterator represents an iterator that limits points per group.
type booleanLimitIterator struct {
	input BooleanIterator
	opt   IteratorOptions
	n     int

	prev struct {
		name string
		tags Tags
	}
}

// newBooleanLimitIterator returns a new instance of booleanLimitIterator.
func newBooleanLimitIterator(input BooleanIterator, opt IteratorOptions) *booleanLimitIterator {
	return &booleanLimitIterator{
		input: input,
		opt:   opt,
	}
}

// Close closes the underlying iterators.
func (itr *booleanLimitIterator) Close() error { return itr.input.Close() }

// Next returns the next point from the iterator.
func (itr *booleanLimitIterator) Next() *BooleanPoint {
	for {
		p := itr.input.Next()
		if p == nil {
			return nil
		}

		// Reset window and counter if a new window is encountered.
		if p.Name != itr.prev.name || !p.Tags.Equals(&itr.prev.tags) {
			itr.prev.name = p.Name
			itr.prev.tags = p.Tags
			itr.n = 0
		}

		// Increment counter.
		itr.n++

		// Read next point if not beyond the offset.
		if itr.n <= itr.opt.Offset {
			continue
		}

		// Read next point if we're beyond the limit.
		if itr.opt.Limit > 0 && (itr.n-itr.opt.Offset) > itr.opt.Limit {
			continue
		}

		return p
	}
}

// booleanJoinIterator represents a join iterator that processes boolean values.
type booleanJoinIterator struct {
	input BooleanIterator
	buf   *BooleanPoint      // next value from input
	c     chan *BooleanPoint // streaming output channel
	once  sync.Once
}

// newBooleanJoinIterator returns a new join iterator that wraps input.
func newBooleanJoinIterator(input BooleanIterator) *booleanJoinIterator {
	return &booleanJoinIterator{
		input: input,
		c:     make(chan *BooleanPoint, 1),
	}
}

// Close close the iterator.
func (itr *booleanJoinIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

// Next returns the next point from the streaming channel.
func (itr *booleanJoinIterator) Next() *BooleanPoint { return <-itr.c }

// loadBuf reads the next value from the input into the buffer.
func (itr *booleanJoinIterator) loadBuf() (t int64, name string, tags Tags) {
	if itr.buf != nil {
		return itr.buf.Time, itr.buf.Name, itr.buf.Tags
	}

	itr.buf = itr.input.Next()
	if itr.buf == nil {
		return ZeroTime, "", Tags{}
	}
	return itr.buf.Time, itr.buf.Name, itr.buf.Tags
}

// emitAt emits the buffered point if its timestamp equals t.
// Otherwise it emits a null value with the timestamp t.
func (itr *booleanJoinIterator) emitAt(t int64, name string, tags Tags) {
	var v *BooleanPoint
	if itr.buf == nil || itr.buf.Time != t || itr.buf.Name != name || !itr.buf.Tags.Equals(&tags) {
		v = &BooleanPoint{Name: name, Tags: tags, Time: t, Value: false}
	} else {
		v, itr.buf = itr.buf, nil
	}
	itr.c <- v
}

// booleanAuxIterator represents a boolean implementation of AuxIterator.
type booleanAuxIterator struct {
	input  *bufBooleanIterator
	output chan *BooleanPoint
	fields auxIteratorFields
}

func newBooleanAuxIterator(input BooleanIterator, opt IteratorOptions) *booleanAuxIterator {
	itr := &booleanAuxIterator{
		input:  newBufBooleanIterator(input),
		output: make(chan *BooleanPoint, 1),
		fields: newAuxIteratorFields(opt),
	}

	// Initialize auxilary fields.
	if p := itr.input.Next(); p != nil {
		itr.output <- p
		itr.fields.init(p)
	}

	go itr.stream()
	return itr
}

func (itr *booleanAuxIterator) Close() error                  { return itr.input.Close() }
func (itr *booleanAuxIterator) Next() *BooleanPoint           { return <-itr.output }
func (itr *booleanAuxIterator) Iterator(name string) Iterator { return itr.fields.iterator(name) }

func (itr *booleanAuxIterator) stream() {
	for {
		// Read next point.
		p := itr.input.Next()
		if p == nil {
			break
		}

		// Send point to output and to each field iterator.
		itr.output <- p
		itr.fields.send(p)
	}

	close(itr.output)
	itr.fields.close()
}

// booleanChanIterator represents a new instance of booleanChanIterator.
type booleanChanIterator struct {
	c    chan *BooleanPoint
	once sync.Once
}

func (itr *booleanChanIterator) Close() error {
	itr.once.Do(func() { close(itr.c) })
	return nil
}

func (itr *booleanChanIterator) Next() *BooleanPoint { return <-itr.c }

// booleanReduceIterator executes a reducer for every interval and buffers the result.
type booleanReduceIterator struct {
	input  *bufBooleanIterator
	fn     booleanReduceFunc
	opt    IteratorOptions
	points []*BooleanPoint
}

// Close closes the iterator and all child iterators.
func (itr *booleanReduceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *booleanReduceIterator) Next() *BooleanPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *booleanReduceIterator) reduce() []*BooleanPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Create points by tags.
	m := make(map[string]*BooleanPoint)
	for {
		// Read next point.
		curr := itr.input.NextInWindow(startTime, endTime)
		if curr == nil {
			break
		}
		tags := curr.Tags.Subset(itr.opt.Dimensions)

		// Pass previous and current points to reducer.
		prev := m[tags.ID()]
		t, v, aux := itr.fn(prev, curr, &reduceOptions)
		if t == ZeroTime {
			continue
		}

		// If previous value didn't exist, create it and copy values.
		if prev == nil {
			prev = &BooleanPoint{Name: curr.Name, Tags: tags}
			m[tags.ID()] = prev
		}
		prev.Time = t
		prev.Value = v
		prev.Aux = aux
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	a := make([]*BooleanPoint, len(m))
	for i, k := range keys {
		a[i] = m[k]
	}

	return a
}

// booleanReduceFunc is the function called by a BooleanPoint reducer.
type booleanReduceFunc func(prev, curr *BooleanPoint, opt *reduceOptions) (t int64, v bool, aux []interface{})

// booleanReduceSliceIterator executes a reducer on all points in a window and buffers the result.
type booleanReduceSliceIterator struct {
	input  *bufBooleanIterator
	fn     booleanReduceSliceFunc
	opt    IteratorOptions
	points []BooleanPoint
}

// Close closes the iterator and all child iterators.
func (itr *booleanReduceSliceIterator) Close() error { return itr.input.Close() }

// Next returns the minimum value for the next available interval.
func (itr *booleanReduceSliceIterator) Next() *BooleanPoint {
	// Calculate next window if we have no more points.
	if len(itr.points) == 0 {
		itr.points = itr.reduce()
		if len(itr.points) == 0 {
			return nil
		}
	}

	// Pop next point off the stack.
	p := itr.points[len(itr.points)-1]
	itr.points = itr.points[:len(itr.points)-1]
	return &p
}

// reduce executes fn once for every point in the next window.
// The previous value for the dimension is passed to fn.
func (itr *booleanReduceSliceIterator) reduce() []BooleanPoint {
	// Calculate next window.
	startTime, endTime := itr.opt.Window(itr.input.PeekTime())

	var reduceOptions = reduceOptions{
		startTime: startTime,
		endTime:   endTime,
	}

	// Group points by name and tagset.
	groups := make(map[string]struct {
		name   string
		tags   Tags
		points []BooleanPoint
	})
	for {
		// Read next point.
		p := itr.input.NextInWindow(startTime, endTime)
		if p == nil {
			break
		}
		tags := p.Tags.Subset(itr.opt.Dimensions)

		// Append point to dimension.
		id := tags.ID()
		g := groups[id]
		g.name = p.Name
		g.tags = tags
		g.points = append(g.points, *p)
		groups[id] = g
	}

	// Reduce each set into a set of values.
	results := make(map[string][]BooleanPoint)
	for key, g := range groups {
		a := itr.fn(g.points, &reduceOptions)
		if len(a) == 0 {
			continue
		}

		// Update name and tags for each returned point.
		for i := range a {
			a[i].Name = g.name
			a[i].Tags = g.tags
		}
		results[key] = a
	}

	// Reverse sort points by name & tag.
	keys := make([]string, 0, len(results))
	for k := range results {
		keys = append(keys, k)
	}
	sort.Sort(sort.Reverse(sort.StringSlice(keys)))

	// Reverse order points within each key.
	a := make([]BooleanPoint, 0, len(results))
	for _, k := range keys {
		for i := len(results[k]) - 1; i >= 0; i-- {
			a = append(a, results[k][i])
		}
	}

	return a
}

// booleanReduceSliceFunc is the function called by a BooleanPoint slice reducer.
type booleanReduceSliceFunc func(a []BooleanPoint, opt *reduceOptions) []BooleanPoint
